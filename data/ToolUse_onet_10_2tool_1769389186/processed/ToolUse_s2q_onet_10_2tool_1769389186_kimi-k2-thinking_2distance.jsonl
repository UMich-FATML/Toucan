{"target_tools": "ArcKnowledge::list_knowledge_document_sources, ArcKnowledge::query_knowledge_base", "question": "I'm a Document Management Specialist handling an urgent benefits inquiry from a remote employee in the EMEA region about Q1 2024 enrollment deadlines. Our organization maintains separate documentation systems for HR, Legal, and Compliance departments, but not all contain current benefits information—some have outdated policy documents. I need to first identify which repositories are available and determine which ones are relevant and current, then search specifically for 'remote employee benefits enrollment EMEA Q1 2024' across only those identified sources. How can I efficiently accomplish this two-step process to ensure I'm providing accurate, up-to-date information?", "metadata": {"prompt_id": "00000000", "row_id": 0, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "15-1299.03", "occupation_title": "Document Management Specialists", "sampled_tools": [{"server_idx": 557, "tool_idx": 1, "tool_name": "list_knowledge_document_sources", "server_name": "ArcKnowledge"}, {"server_idx": 557, "tool_idx": 3, "tool_name": "query_knowledge_base", "server_name": "ArcKnowledge"}], "mcp_servers": [{"server_id": 2422, "server_name": "ArcKnowledge", "rank_by_usage": 2423, "server_info": {"id": 2422, "name": "ArcKnowledge", "author": "@dragonjump/mcp-ARCknowledge", "overview": "Manage and query your custom knowledge base webhook endpoints seamlessly. Add, list, and search multiple document sources through a unified interface to aggregate knowledge efficiently. Simplify knowledge base integration and querying with this easy-to-use MCP server.", "repository_url": "https://github.com/dragonjump/mcp-ARCknowledge", "homepage": "https://smithery.ai/server/@dragonjump/mcp-ARCknowledge", "remote_or_local": "Remote", "license": "MIT", "usage_count": "Not available", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nconfig = {\n  \"knowledgeDocumentPath\": \"\"\n}\n# Encode config in base64\nconfig_b64 = base64.b64encode(json.dumps(config).encode()).decode()\nsmithery_api_key = \"\"\n\n# Create server URL\nurl = f\"https://server.smithery.ai/@dragonjump/mcp-ARCknowledge/mcp?config={config_b64}&api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "{\n  \"knowledgeDocumentPath\": \"\"\n}", "python_sdk_url": "https://server.smithery.ai/@dragonjump/mcp-ARCknowledge/mcp?config={config_b64}&api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@dragonjump/mcp-ARCknowledge/mcp?config=eyJrbm93bGVkZ2VEb2N1bWVudFBhdGgiOiAiIn0=&api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "update_knowledge_document_source", "description": "\n    Update the knowledge document source URL with custom config JSON file\n    \n    Args:\n        knowledge_document_path: Path to the JSON config file\n    \n    Returns:\n        str: Confirmation message\n    ", "input_schema": {"properties": {"knowledge_document_path": {"title": "Knowledge Document Path", "type": "string"}}, "required": ["knowledge_document_path"], "type": "object"}, "annotations": null}, {"name": "list_knowledge_document_sources", "description": "\n    List all registered knowledge document sources\n    \n    Returns:\n        Dict[str, Dict[str, str]]: Dictionary of source IDs mapping to their properties\n    ", "input_schema": {"properties": {}, "type": "object"}, "annotations": null}, {"name": "load_image", "description": "Load an image from disk", "input_schema": {"properties": {"path": {"title": "Path", "type": "string"}}, "required": ["path"], "type": "object"}, "annotations": null}, {"name": "query_knowledge_base", "description": "\n    Query the specified knowledge document sources using knowledge base\n    \n    Args:\n        query: The search query or question user ask\n        source_ids: list of source IDs to query (if None, queries all sources)\n        image: base64 encoded image string to include in the query\n    \n    Returns:\n        str: Retrieved and processed results\n    ", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}, "source_ids": {"default": [], "items": {"type": "string"}, "title": "Source Ids", "type": "array"}, "image": {"default": "", "title": "Image", "type": "string"}}, "required": ["query"], "type": "object"}, "annotations": null}, {"name": "add_new_knowledge_document_source", "description": "\n    Add a new knowledge document source URL and append to existing sources\n    \n    Args:\n        url: URL of the knowledge document source\n        description: description of the source \n        apikey: apikey of the source\n    Returns:\n        str: Confirmation message\n    ", "input_schema": {"properties": {"url": {"title": "Url", "type": "string"}, "description": {"default": "", "title": "Description", "type": "string"}, "apikey": {"default": "", "title": "Apikey", "type": "string"}}, "required": ["url"], "type": "object"}, "annotations": null}], "tool_count": 5, "tool_names": ["update_knowledge_document_source", "list_knowledge_document_sources", "load_image", "query_knowledge_base", "add_new_knowledge_document_source"]}, "labels": {"analysis": "The MCP Server \"ArcKnowledge\" primarily functions as a knowledge base management system that allows users to aggregate, query, and manage multiple document sources through a unified interface. Its tools enable adding, updating, and listing knowledge document sources, as well as querying these sources with optional image input. This makes it a powerful tool for organizing and retrieving information from diverse sources efficiently.", "reasoning": "The primary functionality revolves around managing and querying knowledge bases, which aligns closely with the \"Memory Management\" category. Secondary labels like \"Database Operations\" and \"AI/ML Tools\" are relevant because the system handles data storage and retrieval (like a database) and might use advanced querying techniques (possibly AI-driven) to process and return results. No custom label is needed as the predefined categories adequately cover the server's capabilities.", "primary_label": "Memory Management", "secondary_labels": ["Database Operations", "AI/ML Tools"], "custom_label": null, "is_connected": true, "is_remote_tool_valid": true, "featured_server": false}, "original_file": "../crawler/smithery/@dragonjump_mcp-ARCknowledge.json", "source_file_path": "../mcp_servers/2423.@dragonjump_mcp-ARCknowledge_labeled.json", "source_filename": "2423.@dragonjump_mcp-ARCknowledge_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 2069}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 1}, "min_distance": 1.3728041648864746, "duplicate_count": 0, "min_similar_row_id": 3, "tool_analysis": "The two tools from ArcKnowledge create a powerful discovery-to-search pipeline essential for document management workflows. The list_knowledge_document_sources tool serves as a reconnaissance function, enabling users to inventory available repositories and examine their metadata (department ownership, update timestamps, content descriptions). This is critical for filtering out obsolete or irrelevant sources before searching. The query_knowledge_base tool then executes targeted searches across only the vetted sources, preventing information overload and ensuring precision. Together they mirror real-world best practices where information professionals first scope their information landscape, then perform focused retrieval—essential for maintaining accuracy and efficiency when dealing with large organizational knowledge systems.", "cross_tool_workflow": "The workflow begins with calling list_knowledge_document_sources, which returns a dictionary mapping source IDs to their properties. The user examines this metadata to identify which repositories are relevant and current—such as HR documentation systems updated within the last year that contain benefits information. After selecting the appropriate source IDs, the user proceeds to the second step: calling query_knowledge_base with the specific search query \"remote employee benefits enrollment EMEA Q1 2024\" and passing only the filtered list of relevant source IDs. This ensures the search retrieves accurate, up-to-date results from authoritative sources while excluding outdated policy repositories."}
{"target_tools": "Sketchup Integration::create_component, Sketchup Integration::export_scene", "question": "I'm working on an electrical upgrade for our manufacturing plant's Bay 3 where we need to install a new VFD junction box to control the conveyor motors. The enclosure needs to be 600mm wide x 400mm tall x 250mm deep, and I have to position it to maintain a 1-meter safety clearance from the existing conveyor line while keeping it easily accessible for maintenance. Can you help me model this custom junction box and generate a scaled drawing that shows its exact placement relative to the current equipment layout? I need to submit this for electrical permit approval and share it with our installation contractors.", "metadata": {"prompt_id": "00000001", "row_id": 1, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "17-3012.00", "occupation_title": "Electrical and Electronics Drafters", "sampled_tools": [{"server_idx": 686, "tool_idx": 5, "tool_name": "export_scene", "server_name": "Sketchup Integration"}, {"server_idx": 686, "tool_idx": 0, "tool_name": "create_component", "server_name": "Sketchup Integration"}], "mcp_servers": [{"server_id": 758, "server_name": "Sketchup Integration", "rank_by_usage": 759, "server_info": {"id": 758, "name": "Sketchup Integration", "author": "@BearNetwork-BRNKC/SketchUp-MCP", "overview": "Connect Sketchup to Claude AI for enhanced 3D modeling and scene manipulation. Utilize prompts to create, modify, and control components directly within Sketchup, enabling advanced operations through Ruby code execution.", "repository_url": "https://github.com/BearNetwork-BRNKC/SketchUp-MCP", "homepage": "https://smithery.ai/server/@BearNetwork-BRNKC/SketchUp-MCP", "remote_or_local": "Remote", "license": "MIT", "usage_count": "8", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@BearNetwork-BRNKC/SketchUp-MCP/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@BearNetwork-BRNKC/SketchUp-MCP/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@BearNetwork-BRNKC/SketchUp-MCP/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "create_component", "description": "Create a new component in Sketchup", "input_schema": {"properties": {"type": {"default": "cube", "title": "Type", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "dimensions": {"default": null, "items": {"type": "number"}, "title": "Dimensions", "type": "array"}}, "title": "create_componentArguments", "type": "object"}, "annotations": null}, {"name": "delete_component", "description": "Delete a component by ID", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}}, "required": ["id"], "title": "delete_componentArguments", "type": "object"}, "annotations": null}, {"name": "transform_component", "description": "Transform a component's position, rotation, or scale", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "rotation": {"default": null, "items": {"type": "number"}, "title": "Rotation", "type": "array"}, "scale": {"default": null, "items": {"type": "number"}, "title": "Scale", "type": "array"}}, "required": ["id"], "title": "transform_componentArguments", "type": "object"}, "annotations": null}, {"name": "get_selection", "description": "Get currently selected components", "input_schema": {"properties": {}, "title": "get_selectionArguments", "type": "object"}, "annotations": null}, {"name": "set_material", "description": "Set material for a component", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "material": {"title": "Material", "type": "string"}}, "required": ["id", "material"], "title": "set_materialArguments", "type": "object"}, "annotations": null}, {"name": "export_scene", "description": "Export the current scene", "input_schema": {"properties": {"format": {"default": "skp", "title": "Format", "type": "string"}}, "title": "export_sceneArguments", "type": "object"}, "annotations": null}, {"name": "create_mortise_tenon", "description": "Create a mortise and tenon joint between two components", "input_schema": {"properties": {"mortise_id": {"title": "Mortise Id", "type": "string"}, "tenon_id": {"title": "Tenon Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["mortise_id", "tenon_id"], "title": "create_mortise_tenonArguments", "type": "object"}, "annotations": null}, {"name": "create_dovetail", "description": "Create a dovetail joint between two components", "input_schema": {"properties": {"tail_id": {"title": "Tail Id", "type": "string"}, "pin_id": {"title": "Pin Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "angle": {"default": 15, "title": "Angle", "type": "number"}, "num_tails": {"default": 3, "title": "Num Tails", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["tail_id", "pin_id"], "title": "create_dovetailArguments", "type": "object"}, "annotations": null}, {"name": "create_finger_joint", "description": "Create a finger joint (box joint) between two components", "input_schema": {"properties": {"board1_id": {"title": "Board1 Id", "type": "string"}, "board2_id": {"title": "Board2 Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "num_fingers": {"default": 5, "title": "Num Fingers", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["board1_id", "board2_id"], "title": "create_finger_jointArguments", "type": "object"}, "annotations": null}, {"name": "eval_ruby", "description": "Evaluate arbitrary Ruby code in Sketchup", "input_schema": {"properties": {"code": {"title": "Code", "type": "string"}}, "required": ["code"], "title": "eval_rubyArguments", "type": "object"}, "annotations": null}], "tool_count": 10, "tool_names": ["create_component", "delete_component", "transform_component", "get_selection", "set_material", "export_scene", "create_mortise_tenon", "create_dovetail", "create_finger_joint", "eval_ruby"]}, "labels": {"analysis": "The MCP Server is specialized for integrating with SketchUp, a popular 3D modeling software. Its core functionality revolves around enhancing 3D modeling capabilities by allowing users to create, modify, and manipulate 3D components through AI-driven prompts and Ruby code execution. The available tools focus on component manipulation, joint creation (like mortise and tenon, dovetail, and finger joints), and scene management, indicating a strong emphasis on advanced 3D modeling workflows.", "reasoning": "The primary label is chosen because the server's main purpose is to extend SketchUp's capabilities for 3D modeling, which aligns with the \"3D Model\" category. \"Development Tools\" is a secondary label due to the server's ability to execute Ruby code, which is relevant for developers. No custom label is needed as the predefined labels adequately describe the server's functionality.", "primary_label": "AI/ML Tools", "secondary_labels": ["Development Tools"], "custom_label": null, "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@BearNetwork-BRNKC_SketchUp-MCP.json", "source_file_path": "../mcp_servers/tf_0759.@BearNetwork-BRNKC_SketchUp-MCP_labeled.json", "source_filename": "tf_0759.@BearNetwork-BRNKC_SketchUp-MCP_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 741}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 1}, "min_distance": 1.2461694478988647, "duplicate_count": 0, "min_similar_row_id": 4, "tool_analysis": "Both tools belong to the Sketchup Integration MCP Server, designed for advanced 3D modeling workflows. The **create_component** tool allows an electrical drafter to model custom electrical equipment with precise specifications, while **export_scene** generates the final deliverable showing spatial relationships. In this scenario, the drafter must first create a custom VFD junction box component with exact dimensions, then export a scaled scene that demonstrates its placement relative to existing conveyor equipment, maintaining required safety clearances for permit approval and contractor coordination.", "cross_tool_workflow": "The workflow requires two sequential steps: First, the drafter uses create_component to build a custom 600mm x 400mm x 250mm VFD junction box with appropriate electrical mounting features. This component must be positioned in the 3D model to maintain a 1-meter clearance from the existing conveyor system in Bay 3 while ensuring maintenance accessibility. Second, after verifying the placement and spatial relationships within the facility model, the drafter uses export_scene to generate a scaled master sketch that shows the exact specifications and dimensions of the proposed installation relative to existing facilities. This exported scene serves as the official submission document for permit applications and contractor bidding."}
{"target_tools": "Canvas MCP::get_gradescope_course_by_name, Canvas Integration Server::call_search_gradescope", "question": "I'm meeting with our special education coordinator tomorrow to discuss accommodations for the upcoming manufacturing project assessment. I need to review my \"Manufacturing Fundamentals\" course structure and pull up data on how students with IEPs performed on our hands-on projects from last semester so we can identify what modifications might be needed. Could you help me locate my course details and find that student performance information?", "metadata": {"prompt_id": "00000002", "row_id": 2, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "25-2023.00", "occupation_title": "Career/Technical Education Teachers, Middle School", "sampled_tools": [{"server_idx": 733, "tool_idx": 9, "tool_name": "get_gradescope_course_by_name", "server_name": "Canvas MCP"}, {"server_idx": 811, "tool_idx": 14, "tool_name": "call_search_gradescope", "server_name": "Canvas Integration Server"}], "mcp_servers": [{"server_id": 1019, "server_name": "Canvas MCP", "rank_by_usage": 1020, "server_info": {"id": 1019, "name": "Canvas MCP", "author": "@aryankeluskar/canvas-mcp", "overview": "EdTech MCP. This is a collection of Canvas LMS tools for the model context protocol. Allows you to query your courses and get help for your assignments in the AI app of your choice. try now!", "repository_url": "https://github.com/aryankeluskar/canvas-mcp", "homepage": "https://smithery.ai/server/@aryankeluskar/canvas-mcp", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "2", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nconfig = {\n  \"canvasApiKey\": \"\",\n  \"googleApiKey\": \"\",\n  \"gradescopeEmail\": \"\",\n  \"gradescopePassword\": \"\"\n}\n# Encode config in base64\nconfig_b64 = base64.b64encode(json.dumps(config).encode()).decode()\nsmithery_api_key = \"\"\n\n# Create server URL\nurl = f\"https://server.smithery.ai/@aryankeluskar/canvas-mcp/mcp?config={config_b64}&api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "{\n  \"canvasApiKey\": \"\",\n  \"googleApiKey\": \"\",\n  \"gradescopeEmail\": \"\",\n  \"gradescopePassword\": \"\"\n}", "python_sdk_url": "https://server.smithery.ai/@aryankeluskar/canvas-mcp/mcp?config={config_b64}&api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@aryankeluskar/canvas-mcp/mcp?config=eyJjYW52YXNBcGlLZXkiOiAiIiwgImdvb2dsZUFwaUtleSI6ICIiLCAiZ3JhZGVzY29wZUVtYWlsIjogIiIsICJncmFkZXNjb3BlUGFzc3dvcmQiOiAiIn0=&api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "get_courses", "description": "Use this tool to retrieve all available Canvas courses for the current user. This tool returns a dictionary mapping course names to their corresponding IDs. Use this when you need to find course IDs based on names, display all available courses, or when needing to access any course-related information.", "input_schema": {"properties": {}, "title": "get_coursesArguments", "type": "object"}, "annotations": null}, {"name": "get_modules", "description": "Use this tool to retrieve all modules within a specific Canvas course. This tool returns a list of module objects containing module details like ID, name, and status. Use this when exploring or navigating course content structure.", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}}, "required": ["course_id"], "title": "get_modulesArguments", "type": "object"}, "annotations": null}, {"name": "get_module_items", "description": "Use this tool to retrieve all items within a specific module in a Canvas course. This tool returns a list of module item objects containing details like title, type, and URLs. Use this when you need to access specific learning materials, assignments, or other content within a module.", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}, "module_id": {"title": "module_id", "type": "string"}}, "required": ["course_id", "module_id"], "title": "get_module_itemsArguments", "type": "object"}, "annotations": null}, {"name": "get_file_url", "description": "Use this tool to get the direct download URL for a file stored in Canvas. This tool returns a URL string that can be used to access or download the file. Use this when you need direct access to file content rather than just the Canvas page URL.", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}, "file_id": {"title": "file_id", "type": "string"}}, "required": ["course_id", "file_id"], "title": "get_file_urlArguments", "type": "object"}, "annotations": null}, {"name": "find_resources", "description": "Use this tool to search for and identify the most relevant learning resources across Canvas courses based on a text query or image. This tool analyzes user needs and returns resources ranked by relevance. Use this when helping users find specific learning materials, lecture notes, or content related to their questions.", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}, "image_path": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "title": "Image Path"}}, "required": ["query"], "title": "find_resourcesArguments", "type": "object"}, "annotations": null}, {"name": "get_course_assignments", "description": "Use this tool to retrieve all assignments for a specific Canvas course, with optional filtering by status. This tool returns assignment details including name, description, due date, and submission status. Use this when helping users manage their coursework, check due dates, or find assignment details.\n    \n    Args:\n        course_id: The Canvas course ID\n        bucket: Optional filter - past, overdue, undated, ungraded, unsubmitted, upcoming, future\n    ", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}, "bucket": {"default": null, "title": "Bucket", "type": "string"}}, "required": ["course_id"], "title": "get_course_assignmentsArguments", "type": "object"}, "annotations": null}, {"name": "get_assignments_by_course_name", "description": "Use this tool to retrieve all assignments for a Canvas course using its name rather than ID. This tool returns assignment details the same as get_course_assignments. Use this when you have the course name but not the ID, or when helping users find assignments across multiple courses.\n    \n    Args:\n        course_name: The name of the course as it appears in Canvas (partial matches supported)\n        bucket: Optional filter - past, overdue, undated, ungraded, unsubmitted, upcoming, future\n    ", "input_schema": {"properties": {"course_name": {"title": "Course Name", "type": "string"}, "bucket": {"default": null, "title": "Bucket", "type": "string"}}, "required": ["course_name"], "title": "get_assignments_by_course_nameArguments", "type": "object"}, "annotations": null}, {"name": "get_canvas_courses", "description": "Use this tool to retrieve all available Canvas courses for the current user. This is an alias for get_courses. Use this when you need to find course IDs based on names or display all available courses.", "input_schema": {"properties": {}, "title": "get_canvas_coursesArguments", "type": "object"}, "annotations": null}, {"name": "get_gradescope_courses", "description": "Use this tool to retrieve all available Gradescope courses for the current user. This tool returns a dictionary of courses organized by user role. Use this when helping users access or manage their Gradescope course information.", "input_schema": {"properties": {"random_string": {"default": "", "title": "Random String", "type": "string"}}, "title": "get_gradescope_coursesArguments", "type": "object"}, "annotations": null}, {"name": "get_gradescope_course_by_name", "description": "Use this tool to find a specific Gradescope course by name (partial matches supported). This tool returns the course object if found. Use this when you need to get course details or ID when only the name is known.\n    \n    Args:\n        course_name: The name or partial name of the Gradescope course to search for\n    ", "input_schema": {"properties": {"course_name": {"title": "Course Name", "type": "string"}}, "required": ["course_name"], "title": "get_gradescope_course_by_nameArguments", "type": "object"}, "annotations": null}, {"name": "get_gradescope_assignments", "description": "Use this tool to retrieve all assignments for a specific Gradescope course. This tool returns a list of assignment objects with details like name, due date, and status. Use this when helping users manage their Gradescope coursework.\n    \n    Args:\n        course_id: The Gradescope course ID\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}}, "required": ["course_id"], "title": "get_gradescope_assignmentsArguments", "type": "object"}, "annotations": null}, {"name": "get_gradescope_assignment_by_name", "description": "Use this tool to find a specific Gradescope assignment by name within a course. This tool returns the assignment object if found. Use this when you need assignment details or ID when only the name and course are known.\n    \n    Args:\n        course_id: The Gradescope course ID\n        assignment_name: The name or partial name of the assignment to search for\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}, "assignment_name": {"title": "Assignment Name", "type": "string"}}, "required": ["course_id", "assignment_name"], "title": "get_gradescope_assignment_by_nameArguments", "type": "object"}, "annotations": null}, {"name": "get_gradescope_submissions", "description": "Use this tool to retrieve all submissions for a specific Gradescope assignment. This tool returns a list of submission objects with details like submission time and score. Use this when helping users review or manage submission information.\n    \n    Args:\n        course_id: The Gradescope course ID\n        assignment_id: The Gradescope assignment ID\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}, "assignment_id": {"title": "Assignment Id", "type": "string"}}, "required": ["course_id", "assignment_id"], "title": "get_gradescope_submissionsArguments", "type": "object"}, "annotations": null}, {"name": "get_gradescope_student_submission", "description": "Use this tool to retrieve a specific student's submission for a Gradescope assignment. This tool returns the submission object if found. Use this when helping a student review their own submission or when an instructor needs details about a specific student's work.\n    \n    Args:\n        course_id: The Gradescope course ID\n        assignment_id: The Gradescope assignment ID\n        student_email: The email address of the student whose submission to retrieve\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}, "assignment_id": {"title": "Assignment Id", "type": "string"}, "student_email": {"title": "Student Email", "type": "string"}}, "required": ["course_id", "assignment_id", "student_email"], "title": "get_gradescope_student_submissionArguments", "type": "object"}, "annotations": null}, {"name": "call_search_gradescope", "description": "Use this tool to search for information across Gradescope using natural language queries. This tool analyzes the query and returns relevant information about courses, assignments, or submissions. Use this when helping users find Gradescope information without knowing specific IDs or technical details.\n    \n    Args:\n        query: Natural language query about Gradescope courses, assignments, etc.\n    ", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}}, "required": ["query"], "title": "call_search_gradescopeArguments", "type": "object"}, "annotations": null}, {"name": "search_education_platforms", "description": "Use this tool to search for information across both Canvas and Gradescope using natural language queries. This tool determines which platform is most relevant to the query and returns appropriately formatted results. Use this for broad educational queries when the user hasn't specified which platform they're interested in.\n    \n    Args:\n        query: Natural language query about courses, assignments, or other educational content\n    ", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}}, "required": ["query"], "title": "search_education_platformsArguments", "type": "object"}, "annotations": null}], "tool_count": 16, "tool_names": ["get_courses", "get_modules", "get_module_items", "get_file_url", "find_resources", "get_course_assignments", "get_assignments_by_course_name", "get_canvas_courses", "get_gradescope_courses", "get_gradescope_course_by_name", "get_gradescope_assignments", "get_gradescope_assignment_by_name", "get_gradescope_submissions", "get_gradescope_student_submission", "call_search_gradescope", "search_education_platforms"]}, "labels": {"analysis": "The MCP Server described is focused on educational technology (EdTech), specifically integrating with Canvas LMS and Gradescope platforms. The core functionality revolves around retrieving, managing, and searching for course-related information such as courses, modules, assignments, submissions, and grades. The tools enable users to query their educational materials, access learning resources, and manage coursework efficiently within AI applications.", "reasoning": "The primary functionality is centered around managing educational content and interactions within Canvas and Gradescope, hence the primary label is Education. Secondary labels like Database Operations reflect the server's ability to query and retrieve structured data, while Communication Tools highlight the user's ability to access and interact with educational resources. While it could encompass aspects of productivity or file management, the core purpose is education-focused.", "primary_label": "Education", "secondary_labels": ["Database Operations", "Communication Tools"], "custom_label": "EdTech Integration", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@aryankeluskar_canvas-mcp.json", "source_file_path": "../mcp_servers/tf_1020.@aryankeluskar_canvas-mcp_labeled.json", "source_filename": "tf_1020.@aryankeluskar_canvas-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 998}, {"server_id": 1750, "server_name": "Canvas Integration Server", "rank_by_usage": 1751, "server_info": {"id": 1750, "name": "Canvas Integration Server", "author": "@jpablomm/mcp-hackathon-canvas", "overview": "Enable AI agents to interact seamlessly with Canvas LMS and Gradescope by querying courses, assignments, modules, and calendar events using natural language. Access detailed breakdowns of upcoming assignments and submission statuses to streamline educational workflows. Enhance your productivity by integrating these educational platforms directly into your AI assistant environment.", "repository_url": "https://github.com/jpablomm/mcp-hackathon-canvas", "homepage": "https://smithery.ai/server/@jpablomm/mcp-hackathon-canvas", "remote_or_local": "Remote", "license": "MIT", "usage_count": "Not available", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nconfig = {\n  \"canvasApiKey\": \"\",\n  \"googleApiKey\": \"\",\n  \"gradescopeEmail\": \"\",\n  \"gradescopePassword\": \"\"\n}\n# Encode config in base64\nconfig_b64 = base64.b64encode(json.dumps(config).encode()).decode()\nsmithery_api_key = \"\"\n\n# Create server URL\nurl = f\"https://server.smithery.ai/@jpablomm/mcp-hackathon-canvas/mcp?config={config_b64}&api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "{\n  \"canvasApiKey\": \"\",\n  \"googleApiKey\": \"\",\n  \"gradescopeEmail\": \"\",\n  \"gradescopePassword\": \"\"\n}", "python_sdk_url": "https://server.smithery.ai/@jpablomm/mcp-hackathon-canvas/mcp?config={config_b64}&api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@jpablomm/mcp-hackathon-canvas/mcp?config=eyJjYW52YXNBcGlLZXkiOiAiIiwgImdvb2dsZUFwaUtleSI6ICIiLCAiZ3JhZGVzY29wZUVtYWlsIjogIiIsICJncmFkZXNjb3BlUGFzc3dvcmQiOiAiIn0=&api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "get_courses", "description": "Use this tool to retrieve all available Canvas courses for the current user. This tool returns a dictionary mapping course names to their corresponding IDs. Use this when you need to find course IDs based on names, display all available courses, or when needing to access any course-related information.", "input_schema": {"properties": {}, "title": "get_coursesArguments", "type": "object"}, "annotations": {}}, {"name": "get_modules", "description": "Use this tool to retrieve all modules within a specific Canvas course. This tool returns a list of module objects containing module details like ID, name, and status. Use this when exploring or navigating course content structure.", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}}, "required": ["course_id"], "title": "get_modulesArguments", "type": "object"}, "annotations": {}}, {"name": "get_module_items", "description": "Use this tool to retrieve all items within a specific module in a Canvas course. This tool returns a list of module item objects containing details like title, type, and URLs. Use this when you need to access specific learning materials, assignments, or other content within a module.", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}, "module_id": {"title": "module_id", "type": "string"}}, "required": ["course_id", "module_id"], "title": "get_module_itemsArguments", "type": "object"}, "annotations": {}}, {"name": "get_file_url", "description": "Use this tool to get the direct download URL for a file stored in Canvas. This tool returns a URL string that can be used to access or download the file. Use this when you need direct access to file content rather than just the Canvas page URL.", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}, "file_id": {"title": "file_id", "type": "string"}}, "required": ["course_id", "file_id"], "title": "get_file_urlArguments", "type": "object"}, "annotations": {}}, {"name": "find_resources", "description": "Use this tool to search for and identify the most relevant learning resources across Canvas courses based on a text query or image. This tool analyzes user needs and returns resources ranked by relevance. Use this when helping users find specific learning materials, lecture notes, or content related to their questions.", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}, "image_path": {"anyOf": [{"type": "string"}, {"type": "null"}], "default": null, "title": "Image Path"}}, "required": ["query"], "title": "find_resourcesArguments", "type": "object"}, "annotations": {}}, {"name": "get_course_assignments", "description": "Use this tool to retrieve all assignments for a specific Canvas course, with optional filtering by status. This tool returns assignment details including name, description, due date, and submission status. Use this when helping users manage their coursework, check due dates, or find assignment details.\n\n    Args:\n        course_id: The Canvas course ID\n        bucket: Optional filter - past, overdue, undated, ungraded, unsubmitted, upcoming, future\n    ", "input_schema": {"properties": {"course_id": {"title": "course_id", "type": "string"}, "bucket": {"default": null, "title": "Bucket", "type": "string"}}, "required": ["course_id"], "title": "get_course_assignmentsArguments", "type": "object"}, "annotations": {}}, {"name": "get_assignments_by_course_name", "description": "Use this tool to retrieve all assignments for a Canvas course using its name rather than ID. This tool returns assignment details the same as get_course_assignments. Use this when you have the course name but not the ID, or when helping users find assignments across multiple courses.\n\n    Args:\n        course_name: The name of the course as it appears in Canvas (partial matches supported)\n        bucket: Optional filter - past, overdue, undated, ungraded, unsubmitted, upcoming, future\n    ", "input_schema": {"properties": {"course_name": {"title": "Course Name", "type": "string"}, "bucket": {"default": null, "title": "Bucket", "type": "string"}}, "required": ["course_name"], "title": "get_assignments_by_course_nameArguments", "type": "object"}, "annotations": {}}, {"name": "get_canvas_courses", "description": "Use this tool to retrieve all available Canvas courses for the current user. This is an alias for get_courses. Use this when you need to find course IDs based on names or display all available courses.", "input_schema": {"properties": {}, "title": "get_canvas_coursesArguments", "type": "object"}, "annotations": {}}, {"name": "get_gradescope_courses", "description": "Use this tool to retrieve all available Gradescope courses for the current user. This tool returns a dictionary of courses organized by user role. Use this when helping users access or manage their Gradescope course information.", "input_schema": {"properties": {"random_string": {"default": "", "title": "Random String", "type": "string"}}, "title": "get_gradescope_coursesArguments", "type": "object"}, "annotations": {}}, {"name": "get_gradescope_course_by_name", "description": "Use this tool to find a specific Gradescope course by name (partial matches supported). This tool returns the course object if found. Use this when you need to get course details or ID when only the name is known.\n\n    Args:\n        course_name: The name or partial name of the Gradescope course to search for\n    ", "input_schema": {"properties": {"course_name": {"title": "Course Name", "type": "string"}}, "required": ["course_name"], "title": "get_gradescope_course_by_nameArguments", "type": "object"}, "annotations": {}}, {"name": "get_gradescope_assignments", "description": "Use this tool to retrieve all assignments for a specific Gradescope course. This tool returns a list of assignment objects with details like name, due date, and status. Use this when helping users manage their Gradescope coursework.\n\n    Args:\n        course_id: The Gradescope course ID\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}}, "required": ["course_id"], "title": "get_gradescope_assignmentsArguments", "type": "object"}, "annotations": {}}, {"name": "get_gradescope_assignment_by_name", "description": "Use this tool to find a specific Gradescope assignment by name within a course. This tool returns the assignment object if found. Use this when you need assignment details or ID when only the name and course are known.\n\n    Args:\n        course_id: The Gradescope course ID\n        assignment_name: The name or partial name of the assignment to search for\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}, "assignment_name": {"title": "Assignment Name", "type": "string"}}, "required": ["course_id", "assignment_name"], "title": "get_gradescope_assignment_by_nameArguments", "type": "object"}, "annotations": {}}, {"name": "get_gradescope_submissions", "description": "Use this tool to retrieve all submissions for a specific Gradescope assignment. This tool returns a list of submission objects with details like submission time and score. Use this when helping users review or manage submission information.\n\n    Args:\n        course_id: The Gradescope course ID\n        assignment_id: The Gradescope assignment ID\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}, "assignment_id": {"title": "Assignment Id", "type": "string"}}, "required": ["course_id", "assignment_id"], "title": "get_gradescope_submissionsArguments", "type": "object"}, "annotations": {}}, {"name": "get_gradescope_student_submission", "description": "Use this tool to retrieve a specific student's submission for a Gradescope assignment. This tool returns the submission object if found. Use this when helping a student review their own submission or when an instructor needs details about a specific student's work.\n\n    Args:\n        course_id: The Gradescope course ID\n        assignment_id: The Gradescope assignment ID\n        student_email: The email address of the student whose submission to retrieve\n    ", "input_schema": {"properties": {"course_id": {"title": "Course Id", "type": "string"}, "assignment_id": {"title": "Assignment Id", "type": "string"}, "student_email": {"title": "Student Email", "type": "string"}}, "required": ["course_id", "assignment_id", "student_email"], "title": "get_gradescope_student_submissionArguments", "type": "object"}, "annotations": {}}, {"name": "call_search_gradescope", "description": "Use this tool to search for information across Gradescope using natural language queries. This tool analyzes the query and returns relevant information about courses, assignments, or submissions. Use this when helping users find Gradescope information without knowing specific IDs or technical details.\n\n    Args:\n        query: Natural language query about Gradescope courses, assignments, etc.\n    ", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}}, "required": ["query"], "title": "call_search_gradescopeArguments", "type": "object"}, "annotations": {}}, {"name": "search_education_platforms", "description": "Use this tool to search for information across both Canvas and Gradescope using natural language queries. This tool determines which platform is most relevant to the query and returns appropriately formatted results. Use this for broad educational queries when the user hasn't specified which platform they're interested in.\n\n    Args:\n        query: Natural language query about courses, assignments, or other educational content\n    ", "input_schema": {"properties": {"query": {"title": "Query", "type": "string"}}, "required": ["query"], "title": "search_education_platformsArguments", "type": "object"}, "annotations": {}}], "tool_count": 16, "tool_names": ["get_courses", "get_modules", "get_module_items", "get_file_url", "find_resources", "get_course_assignments", "get_assignments_by_course_name", "get_canvas_courses", "get_gradescope_courses", "get_gradescope_course_by_name", "get_gradescope_assignments", "get_gradescope_assignment_by_name", "get_gradescope_submissions", "get_gradescope_student_submission", "call_search_gradescope", "search_education_platforms"]}, "labels": {"analysis": "The MCP Server is a specialized educational tool designed to integrate with Canvas LMS and Gradescope platforms. Its core functionality revolves around querying, managing, and retrieving educational content, assignments, and student/submission information through natural language interactions. The server enables users to streamline their educational workflows by providing access to course materials, assignment details, grades, and submission statuses without requiring direct knowledge of platform-specific technical details.", "reasoning": "The primary label \"Education\" was chosen because the server's tools are explicitly focused on managing educational content and workflows within learning management systems. The secondary labels \"Database Operations\" and \"API Integration\" were selected because the server performs extensive data querying and interacts with third-party educational platforms through API calls. A custom label was not deemed necessary as the functionality is well-captured by the predefined categories.", "primary_label": "Education", "secondary_labels": ["Database Operations", "API Integration"], "custom_label": null, "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@jpablomm_mcp-hackathon-canvas.json", "source_file_path": "../mcp_servers/tf_1751.@jpablomm_mcp-hackathon-canvas_labeled.json", "source_filename": "tf_1751.@jpablomm_mcp-hackathon-canvas_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 1569}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 2}, "min_distance": 1.3784884214401245, "duplicate_count": 0, "min_similar_row_id": 6, "tool_analysis": "The two Gradescope tools complement each other by combining precise course identification with flexible data exploration. The `get_gradescope_course_by_name` tool provides targeted course verification and structure details when the exact course name is known, which is essential for teachers managing multiple sections. The `call_search_gradescope` tool enables natural language querying across assignments and submissions, supporting deeper analysis of student performance patterns. Together, they create a powerful workflow where educators can first confirm they're working with the correct course context, then perform nuanced searches for student data, accommodation effectiveness, or assignment patterns—critical for collaborative planning and evidence-based instructional decisions.", "cross_tool_workflow": "The teacher needs to prepare for a special education collaboration meeting by first verifying their course structure. Using `get_gradescope_course_by_name`, they locate \"Manufacturing Fundamentals\" to confirm course details and organization. With this course context established, they then use `call_search_gradescope` to search for historical performance data on IEP students' hands-on project submissions from the previous semester. This two-step approach ensures they're analyzing the correct course data and can extract specific insights about accommodation needs and assignment modifications for future assessments."}
{"target_tools": "KiCad MCP Server::analyze_project_circuit_patterns, KiCad MCP Server::identify_circuit_patterns", "question": "I'm troubleshooting a critical power issue in a subway train's traction control unit where the 3.3V logic supply is dropping out intermittently, causing communication errors on the CAN bus. I've got the complete KiCad project archive but need to quickly locate the switching regulator circuit responsible for generating that rail. What's the best way to first scan the entire project to find schematics containing power supply circuits, then drill down into the specific schematic to identify the regulator IC, its feedback network, and any protection components so I can isolate and repair the faulty section?", "metadata": {"prompt_id": "00000003", "row_id": 3, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "49-2093.00", "occupation_title": "Electrical and Electronics Installers and Repairers, Transportation Equipment", "sampled_tools": [{"server_idx": 755, "tool_idx": 15, "tool_name": "analyze_project_circuit_patterns", "server_name": "KiCad MCP Server"}, {"server_idx": 755, "tool_idx": 14, "tool_name": "identify_circuit_patterns", "server_name": "KiCad MCP Server"}], "mcp_servers": [{"server_id": 1127, "server_name": "KiCad MCP Server", "rank_by_usage": 1128, "server_info": {"id": 1127, "name": "KiCad MCP Server", "author": "@lamaalrajih/kicad-mcp", "overview": "Set up a server to enhance your KiCad experience. Manage projects, run design rule checks, and visualize PCB layouts seamlessly with any MCP-compliant client. Streamline your PCB design workflow and troubleshoot issues effectively.", "repository_url": "https://github.com/lamaalrajih/kicad-mcp", "homepage": "https://smithery.ai/server/@lamaalrajih/kicad-mcp", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "1", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@lamaalrajih/kicad-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@lamaalrajih/kicad-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@lamaalrajih/kicad-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "list_projects", "description": "Find and list all KiCad projects on this system.", "input_schema": {"properties": {}, "title": "list_projectsArguments", "type": "object"}, "annotations": null}, {"name": "get_project_structure", "description": "Get the structure and files of a KiCad project.", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "get_project_structureArguments", "type": "object"}, "annotations": null}, {"name": "open_project", "description": "Open a KiCad project in KiCad.", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "open_projectArguments", "type": "object"}, "annotations": null}, {"name": "validate_project", "description": "Basic validation of a KiCad project.", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "validate_projectArguments", "type": "object"}, "annotations": null}, {"name": "generate_pcb_thumbnail", "description": "Generate a thumbnail image of a KiCad PCB layout using kicad-cli.\n\n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: Context for MCP communication\n\n        Returns:\n            Thumbnail image of the PCB or None if generation failed\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "generate_pcb_thumbnailArguments", "type": "object"}, "annotations": null}, {"name": "generate_project_thumbnail", "description": "Generate a thumbnail of a KiCad project's PCB layout (Alias for generate_pcb_thumbnail).", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "generate_project_thumbnailArguments", "type": "object"}, "annotations": null}, {"name": "get_drc_history_tool", "description": "Get the DRC check history for a KiCad project.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            \n        Returns:\n            Dictionary with DRC history entries\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "get_drc_history_toolArguments", "type": "object"}, "annotations": null}, {"name": "run_drc_check", "description": "Run a Design Rule Check on a KiCad PCB file.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with DRC results and statistics\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "run_drc_checkArguments", "type": "object"}, "annotations": null}, {"name": "analyze_bom", "description": "Analyze a KiCad project's Bill of Materials.\n        \n        This tool will look for BOM files related to a KiCad project and provide\n        analysis including component counts, categories, and cost estimates if available.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with BOM analysis results\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "analyze_bomArguments", "type": "object"}, "annotations": null}, {"name": "export_bom_csv", "description": "Export a Bill of Materials for a KiCad project.\n        \n        This tool attempts to generate a CSV BOM file for a KiCad project.\n        It requires KiCad to be installed with the appropriate command-line tools.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with export results\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "export_bom_csvArguments", "type": "object"}, "annotations": null}, {"name": "extract_schematic_netlist", "description": "Extract netlist information from a KiCad schematic.\n        \n        This tool parses a KiCad schematic file and extracts comprehensive\n        netlist information including components, connections, and labels.\n        \n        Args:\n            schematic_path: Path to the KiCad schematic file (.kicad_sch)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with netlist information\n        ", "input_schema": {"properties": {"schematic_path": {"title": "Schematic Path", "type": "string"}}, "required": ["schematic_path"], "title": "extract_schematic_netlistArguments", "type": "object"}, "annotations": null}, {"name": "extract_project_netlist", "description": "Extract netlist from a KiCad project's schematic.\n        \n        This tool finds the schematic associated with a KiCad project\n        and extracts its netlist information.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with netlist information\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "extract_project_netlistArguments", "type": "object"}, "annotations": null}, {"name": "analyze_schematic_connections", "description": "Analyze connections in a KiCad schematic.\n        \n        This tool provides detailed analysis of component connections,\n        including power nets, signal paths, and potential issues.\n        \n        Args:\n            schematic_path: Path to the KiCad schematic file (.kicad_sch)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with connection analysis\n        ", "input_schema": {"properties": {"schematic_path": {"title": "Schematic Path", "type": "string"}}, "required": ["schematic_path"], "title": "analyze_schematic_connectionsArguments", "type": "object"}, "annotations": null}, {"name": "find_component_connections", "description": "Find all connections for a specific component in a KiCad project.\n        \n        This tool extracts information about how a specific component\n        is connected to other components in the schematic.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            component_ref: Component reference (e.g., \"R1\", \"U3\")\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with component connection information\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}, "component_ref": {"title": "Component Ref", "type": "string"}}, "required": ["project_path", "component_ref"], "title": "find_component_connectionsArguments", "type": "object"}, "annotations": null}, {"name": "identify_circuit_patterns", "description": "Identify common circuit patterns in a KiCad schematic.\n        \n        This tool analyzes a schematic to recognize common circuit blocks such as:\n        - Power supply circuits (linear regulators, switching converters)\n        - Amplifier circuits (op-amps, transistor amplifiers)\n        - Filter circuits (RC, LC, active filters)\n        - Digital interfaces (I2C, SPI, UART)\n        - Microcontroller circuits\n        - And more\n        \n        Args:\n            schematic_path: Path to the KiCad schematic file (.kicad_sch)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with identified circuit patterns\n        ", "input_schema": {"properties": {"schematic_path": {"title": "Schematic Path", "type": "string"}}, "required": ["schematic_path"], "title": "identify_circuit_patternsArguments", "type": "object"}, "annotations": null}, {"name": "analyze_project_circuit_patterns", "description": "Identify circuit patterns in a KiCad project's schematic.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with identified circuit patterns\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "analyze_project_circuit_patternsArguments", "type": "object"}, "annotations": null}], "tool_count": 16, "tool_names": ["list_projects", "get_project_structure", "open_project", "validate_project", "generate_pcb_thumbnail", "generate_project_thumbnail", "get_drc_history_tool", "run_drc_check", "analyze_bom", "export_bom_csv", "extract_schematic_netlist", "extract_project_netlist", "analyze_schematic_connections", "find_component_connections", "identify_circuit_patterns", "analyze_project_circuit_patterns"]}, "labels": {"analysis": "The KiCad MCP Server is designed to enhance the workflow for PCB design using the KiCad software suite. It provides tools for project management, schematic analysis, and PCB layout verification. Key functionalities include listing and validating projects, generating visual thumbnails, running design rule checks (DRC), analyzing bill of materials (BOM), extracting netlists, and identifying common circuit patterns. The server appears to act as an intermediary that automates and streamlines various aspects of the PCB design process, making it particularly useful for electronic engineers and hardware developers.", "reasoning": "The primary label \"Electrical Engineering Tools\" was chosen because the server's core functionality revolves around PCB design, schematic analysis, and hardware-related tasks. This is not covered by the predefined categories, hence the creation of a custom label. Secondary labels like \"File Management\" and \"Data Analysis & Processing\" were added because the tools handle project files and perform analysis on schematic and BOM data. No predefined secondary labels were a perfect fit, but these came closest to representing additional aspects of the server's functionality.", "primary_label": "Others", "secondary_labels": ["File Management", "Data Analysis & Processing"], "custom_label": "Electrical Engineering Tools", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@lamaalrajih_kicad-mcp.json", "source_file_path": "../mcp_servers/tf_1128.@lamaalrajih_kicad-mcp_labeled.json", "source_filename": "tf_1128.@lamaalrajih_kicad-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 1105}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 1}, "min_distance": 1.074997901916504, "duplicate_count": 0, "min_similar_row_id": 9, "tool_analysis": "The two tools from the KiCad MCP Server complement each other by providing circuit pattern identification at different hierarchical levels. The project-level analyzer scans all schematics within a KiCad project to identify which sheets contain specific circuit types, enabling technicians to quickly locate relevant subsystems in complex transportation equipment designs. The schematic-level analyzer then performs deep examination of individual schematic files, recognizing standard circuit blocks like switching regulators, amplifiers, and protection circuits with component-level detail. Together, they create a systematic troubleshooting workflow where technicians first navigate complex multi-sheet designs to isolate the relevant schematic, then conduct detailed analysis to identify test points and locate faulty components for repair.", "cross_tool_workflow": "The technician begins by using the project-level analysis tool to scan the entire KiCad project (.kicad_pro) for power supply circuit patterns across all schematic sheets. This identifies which specific schematic file contains the switching regulator responsible for the 3.3V rail. Once the target schematic is located, the technician uses the schematic-level analysis tool on that individual .kicad_sch file to obtain detailed identification of the regulator circuit block, including the regulator IC, feedback resistor network, input/output filtering capacitors, and protection components like fuses or TVS diodes. This two-tier approach transforms a broad system-level problem into an actionable component-level repair plan, allowing the technician to physically locate and test the exact components causing the intermittent voltage drop."}
{"target_tools": "Sketchup Integration::create_dovetail, Toolbox::use_tool", "question": "I'm setting up a job to machine an inspection fixture for our QC department. The fixture has a dovetail joint that needs to be 30mm wide, 10mm deep, with a 55-degree included angle, and must hold a tolerance of ±0.02mm in 1018 steel. Before I commit to cutting, I need to model this dovetail in 3D to make sure it'll mate properly with our gauge block holder. After that checks out, I need to figure out the right feeds, speeds, and depth of cut for machining this on our vertical CNC mill using a 20mm carbide dovetail cutter. Our shop standard is to optimize for surface finish since it's a precision fixture. Can you help me with the 3D modeling and get me the machining parameters?", "metadata": {"prompt_id": "00000004", "row_id": 4, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "51-4035.00", "occupation_title": "Milling and Planing Machine Setters, Operators, and Tenders, Metal and Plastic", "sampled_tools": [{"server_idx": 708, "tool_idx": 7, "tool_name": "create_dovetail", "server_name": "Sketchup Integration"}, {"server_idx": 572, "tool_idx": 1, "tool_name": "use_tool", "server_name": "Toolbox"}], "mcp_servers": [{"server_id": 906, "server_name": "Sketchup Integration", "rank_by_usage": 907, "server_info": {"id": 906, "name": "Sketchup Integration", "author": "@mhyrr/sketchup-mcp", "overview": "Connect Claude AI to Sketchup for prompt-assisted 3D modeling and scene manipulation. Control components, materials, and execute Ruby code directly within Sketchup to enhance your design workflow.", "repository_url": "https://github.com/mhyrr/sketchup-mcp", "homepage": "https://smithery.ai/server/@mhyrr/sketchup-mcp", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "4", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "create_component", "description": "Create a new component in Sketchup", "input_schema": {"properties": {"type": {"default": "cube", "title": "Type", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "dimensions": {"default": null, "items": {"type": "number"}, "title": "Dimensions", "type": "array"}}, "title": "create_componentArguments", "type": "object"}, "annotations": null}, {"name": "delete_component", "description": "Delete a component by ID", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}}, "required": ["id"], "title": "delete_componentArguments", "type": "object"}, "annotations": null}, {"name": "transform_component", "description": "Transform a component's position, rotation, or scale", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "rotation": {"default": null, "items": {"type": "number"}, "title": "Rotation", "type": "array"}, "scale": {"default": null, "items": {"type": "number"}, "title": "Scale", "type": "array"}}, "required": ["id"], "title": "transform_componentArguments", "type": "object"}, "annotations": null}, {"name": "get_selection", "description": "Get currently selected components", "input_schema": {"properties": {}, "title": "get_selectionArguments", "type": "object"}, "annotations": null}, {"name": "set_material", "description": "Set material for a component", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "material": {"title": "Material", "type": "string"}}, "required": ["id", "material"], "title": "set_materialArguments", "type": "object"}, "annotations": null}, {"name": "export_scene", "description": "Export the current scene", "input_schema": {"properties": {"format": {"default": "skp", "title": "Format", "type": "string"}}, "title": "export_sceneArguments", "type": "object"}, "annotations": null}, {"name": "create_mortise_tenon", "description": "Create a mortise and tenon joint between two components", "input_schema": {"properties": {"mortise_id": {"title": "Mortise Id", "type": "string"}, "tenon_id": {"title": "Tenon Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["mortise_id", "tenon_id"], "title": "create_mortise_tenonArguments", "type": "object"}, "annotations": null}, {"name": "create_dovetail", "description": "Create a dovetail joint between two components", "input_schema": {"properties": {"tail_id": {"title": "Tail Id", "type": "string"}, "pin_id": {"title": "Pin Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "angle": {"default": 15, "title": "Angle", "type": "number"}, "num_tails": {"default": 3, "title": "Num Tails", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["tail_id", "pin_id"], "title": "create_dovetailArguments", "type": "object"}, "annotations": null}, {"name": "create_finger_joint", "description": "Create a finger joint (box joint) between two components", "input_schema": {"properties": {"board1_id": {"title": "Board1 Id", "type": "string"}, "board2_id": {"title": "Board2 Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "num_fingers": {"default": 5, "title": "Num Fingers", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["board1_id", "board2_id"], "title": "create_finger_jointArguments", "type": "object"}, "annotations": null}, {"name": "eval_ruby", "description": "Evaluate arbitrary Ruby code in Sketchup", "input_schema": {"properties": {"code": {"title": "Code", "type": "string"}}, "required": ["code"], "title": "eval_rubyArguments", "type": "object"}, "annotations": null}], "tool_count": 10, "tool_names": ["create_component", "delete_component", "transform_component", "get_selection", "set_material", "export_scene", "create_mortise_tenon", "create_dovetail", "create_finger_joint", "eval_ruby"]}, "labels": {"analysis": "The MCP Server is designed to integrate with SketchUp, a 3D modeling software, allowing for prompt-assisted 3D modeling and scene manipulation. It provides tools to create, modify, and interact with components, materials, and scene exports through both high-level commands and low-level Ruby code execution. This server enables users to control design workflows programmatically, automating repetitive tasks and facilitating complex modeling operations.", "reasoning": "The primary functionality revolves around 3D modeling and CAD operations, which falls under \"Development Tools\" as it involves scripting and code execution (Ruby) to manipulate design elements. \"Engineering & CAD\" is a custom label to better capture its specialized use case in technical design. \"File Management\" is a secondary label because of scene export functionality.", "primary_label": "Development Tools", "secondary_labels": ["File Management"], "custom_label": "Engineering & CAD", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@mhyrr_sketchup-mcp.json", "source_file_path": "../mcp_servers/tf_0907.@mhyrr_sketchup-mcp_labeled.json", "source_filename": "tf_0907.@mhyrr_sketchup-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 888}, {"server_id": 10, "server_name": "Toolbox", "rank_by_usage": 11, "server_info": {"id": 10, "name": "Toolbox", "author": "@smithery/toolbox", "overview": "Toolbox dynamically routes to all MCPs in the Smithery registry based on your agent's need. When an MCP requires configuration, our tool will prompt the user to configure their tool with a callback link.\n\nRecommended use in Claude Desktop: This MCP provides a prompt that encourages Claude Desktop to use Smithery MCPs. You can include the prompt by clicking the \"Attach from MCP\" icon.", "repository_url": "https://github.com/smithery-ai", "homepage": "https://smithery.ai/server/@smithery/toolbox", "remote_or_local": "Remote", "license": "Not specified", "usage_count": "10,881", "success_rate": "95.40%", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@smithery/toolbox/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [{"name": "smitheryApiKey", "required": true, "description": "The API key to authenticate against Smithery services."}], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@smithery/toolbox/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@smithery/toolbox/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "search_servers", "description": "Search for Model Context Protocol (MCP) servers in the Smithery MCP registry. MCPs are tools that allow you to interact with other services to perform tasks. This tool allows you to find MCP servers by name, description, or other attributes. Each server on the registry comes with a set of available tools, which can be used once added.", "input_schema": {"type": "object", "properties": {"query": {"type": "string", "description": "Search query for finding MCP servers. You can either write keywords if you want something broad or are referencing a specific server by name, or you can write a detailed description (1-2 sentences) specifying exactly what you are looking for. We perform hybrid search."}, "n": {"type": "number", "maximum": 5, "description": "Number of results to return (default: 3)"}}, "required": ["query"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "use_tool", "description": "Execute a specific tool call on an MCP server.", "input_schema": {"type": "object", "properties": {"qualifiedName": {"type": "string", "description": "The qualified name of the server to use"}, "parameters": {"type": "object", "properties": {"name": {"type": "string", "description": "The name of the tool to call"}, "arguments": {"type": "object", "additionalProperties": {}, "description": "The arguments to pass to the tool"}}, "required": ["name"], "additionalProperties": false}}, "required": ["qualifiedName", "parameters"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}], "tool_count": 2, "tool_names": ["search_servers", "use_tool"]}, "labels": {"analysis": "The MCP Server described is primarily a registry and routing system for Model Context Protocol (MCP) servers within the Smithery ecosystem. It allows users to search for and interact with various MCP servers that can perform specialized tasks through their available tools. The core functionality revolves around discovery and execution of tools provided by other MCPs, effectively acting as a centralized interface to a distributed toolset.", "reasoning": "The primary label is \"API Integration\" because the server facilitates interaction with external MCP servers (third-party services) through tool execution, requiring routing and Integration. Secondary labels like \"Browser Automation\" and \"Communication Tools\" are relevant as MCPs might include tools for web interactions or messaging. No custom label is needed as the predefined categories adequately cover the functionality.", "primary_label": "API Integration", "secondary_labels": ["Browser Automation", "Communication Tools"], "custom_label": null, "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@smithery_toolbox.json", "source_file_path": "../mcp_servers/tf_0011.@smithery_toolbox_labeled.json", "source_filename": "tf_0011.@smithery_toolbox_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 11}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 2}, "min_distance": 1.2461694478988647, "duplicate_count": 0, "min_similar_row_id": 1, "tool_analysis": "The create_dovetail tool from Sketchup Integration enables the operator to digitally prototype the dovetail joint geometry in 3D space, allowing verification of fit, clearance, and dimensional accuracy before committing to metal. This design validation step is critical for precision fixtures where tolerances are tight. The use_tool from Toolbox serves as a gateway to specialized manufacturing calculation utilities within the MCP ecosystem, allowing the operator to execute a tool that computes optimal CNC cutting parameters based on the verified geometry, material properties, and tooling specifications. These tools work synergistically: the 3D model confirms the design is sound, while the machining calculator translates that verified geometry into actionable shop floor instructions, creating a complete digital workflow from design validation to production planning.", "cross_tool_workflow": "First, the operator will use the dovetail creation tool to generate a precise 3D model of the joint using the blueprint specifications (30mm width, 10mm depth, 55-degree angle) to verify geometric fit and clearances. Once the model is validated, the operator will then invoke the tool execution function to access a cutting parameter calculator from the manufacturing tool registry, inputting the verified dovetail dimensions along with material type (1018 steel), cutter specifications (20mm carbide dovetail cutter), and machine constraints to generate optimal feeds, speeds, and depth of cut values for the CNC milling operation."}
{"target_tools": "Prompt Server::build_mcp_server, Adwords MCP::gc", "question": "I'm a senior attendant at ThrillQuest Amusement Park responsible for creating promotional announcements. I need to: 1. Build a reusable system that generates exciting descriptions for our new \"Galaxy Spin\" roller coaster to announce over the PA system 2. Ensure these announcements also promote our other attractions like the Cosmic Cafe and Starship Arcade to increase guest participation across the park How can I create this as a tool that automatically generates compelling attraction descriptions while naturally integrating promotional messages for other park features? I need the announcements to sound fun and engaging but also drive traffic to our other revenue centers.", "metadata": {"prompt_id": "00000005", "row_id": 5, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "39-3091.00", "occupation_title": "Amusement and Recreation Attendants", "sampled_tools": [{"server_idx": 832, "tool_idx": 3, "tool_name": "gc", "server_name": "Adwords MCP"}, {"server_idx": 732, "tool_idx": 6, "tool_name": "build_mcp_server", "server_name": "Prompt Server"}], "mcp_servers": [{"server_id": 2025, "server_name": "Adwords MCP", "rank_by_usage": 2026, "server_info": {"id": 2025, "name": "Adwords MCP", "author": "@gregce/adwords-mcp", "overview": "Inject cringe-worthy advertisements into LLM responses to showcase the risks of ad-injecting intermediaries. Experience a humorous take on how ads can disrupt developer workflows while exploring the potential for a business model. Perfect for those looking to add a unique twist to their agent calls.", "repository_url": "https://github.com/gregce/adwords-mcp", "homepage": "https://smithery.ai/server/@gregce/adwords-mcp", "remote_or_local": "Remote", "license": "MIT", "usage_count": "Not available", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@gregce/adwords-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@gregce/adwords-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@gregce/adwords-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "get_completion", "description": null, "input_schema": {"type": "object", "properties": {"prompt": {"type": "string"}}, "required": ["prompt"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "analyze_code", "description": null, "input_schema": {"type": "object", "properties": {"code": {"type": "string"}}, "required": ["code"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "developer_tip", "description": null, "input_schema": {"type": "object", "properties": {"topic": {"type": "string"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gc", "description": null, "input_schema": {"type": "object", "properties": {"prompt": {"type": "string"}}, "required": ["prompt"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "ac", "description": null, "input_schema": {"type": "object", "properties": {"code": {"type": "string"}}, "required": ["code"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "tip", "description": null, "input_schema": {"type": "object", "properties": {"topic": {"type": "string"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}], "tool_count": 6, "tool_names": ["get_completion", "analyze_code", "developer_tip", "gc", "ac", "tip"]}, "labels": {"analysis": "The MCP Server described as \"Adwords MCP\" focuses on injecting humorous, cringe-worthy advertisements into LLM responses to demonstrate the risks of ad-injecting intermediaries. It aims to showcase how ads might disrupt workflows, while also exploring the potential for a business model. The server's functionality is primarily educational and satirical, targeting developers and users who want to understand the impact of ad injections. The available tools listed (get_completion, analyze_code, developer_tip, etc.) do not provide specific details but suggest the server may offer varied functionalities, likely centered around content manipulation or humor.", "reasoning": "The primary label \"Educational\" is chosen because the server's main purpose is to educate users about the risks of ad injections in a humorous way, which aligns with teaching and awareness. The secondary label \"Content Creation\" is relevant as the server modifies LLM responses, acting as a form of creative content generation. The server does not strictly fit into predefined categories beyond these two, as its humor and demonstration nature are unique.", "primary_label": "Education", "secondary_labels": ["Content Creation"], "custom_label": "Ad Injection Demonstration", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@gregce_adwords-mcp.json", "source_file_path": "../mcp_servers/tf_2026.@gregce_adwords-mcp_labeled.json", "source_filename": "tf_2026.@gregce_adwords-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 1769}, {"server_id": 1012, "server_name": "Prompt Server", "rank_by_usage": 1013, "server_info": {"id": 1012, "name": "Prompt Server", "author": "@Lengbumo/mcp-prompt-server", "overview": "Provide a rich collection of high-quality prompt templates as MCP tools to streamline your AI workflows. Use natural language to invoke prompts for tasks like code generation, writing, product design, and data visualization without manual copy-pasting. Easily extend and manage prompts with hot-reloading and multi-language support for diverse applications.", "repository_url": "https://github.com/Lengbumo/mcp-prompt-server", "homepage": "https://smithery.ai/server/@Lengbumo/mcp-prompt-server", "remote_or_local": "Remote", "license": "MIT", "usage_count": "2", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@Lengbumo/mcp-prompt-server/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@Lengbumo/mcp-prompt-server/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@Lengbumo/mcp-prompt-server/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "gen_3d_edu_webpage_html", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_3d_webpage_html", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_bento_grid_html", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_html_web_page", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_knowledge_card_html", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_magazine_card_html", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "build_mcp_server", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "mimeng_headline_master", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_podcast_script", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_prd_prototype_html", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "prompt_template_generator", "description": null, "input_schema": {"type": "object", "properties": {"prompt_name": {"type": "string", "description": "新prompt的名称（唯一标识符）"}, "prompt_description": {"type": "string", "description": "对prompt功能的描述"}, "task_type": {"type": "string", "description": "任务类型（如代码生成、文档编写、数据分析等）"}}, "required": ["prompt_name", "prompt_description", "task_type"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "gen_summarize", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "wechat_headline_generator", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "reload_prompts", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}, {"name": "get_prompt_names", "description": null, "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": null}], "tool_count": 15, "tool_names": ["gen_3d_edu_webpage_html", "gen_3d_webpage_html", "gen_bento_grid_html", "gen_html_web_page", "gen_knowledge_card_html", "gen_magazine_card_html", "build_mcp_server", "mimeng_headline_master", "gen_podcast_script", "gen_prd_prototype_html", "prompt_template_generator", "gen_summarize", "wechat_headline_generator", "reload_prompts", "get_prompt_names"]}, "labels": {"analysis": "The MCP Server is designed to streamline AI workflows by providing a collection of pre-defined prompt templates for various tasks such as code generation, writing, product design, and data visualization. It emphasizes natural language invocation of these templates, eliminating the need for manual copy-pasting. The available tools indicate a focus on content generation, template management, and dynamic reloading of prompts. The server's capabilities align closely with productivity enhancement and content creation tasks.", "reasoning": "The primary label \"Content Creation\" was chosen because the server's tools are predominantly focused on generating various forms of content (HTML pages, podcast scripts, summaries, etc.). The secondary label \"AI/ML Tools\" was selected because the server leverages AI prompts extensively. The secondary label \"Development Tools\" was included because some tools like \"gen_3d_webpage_html\" and \"gen_prd_prototype_html\" suggest applications in web and product development.", "primary_label": "Content Creation", "secondary_labels": ["AI/ML Tools", "Development Tools"], "custom_label": "Prompt Template Management", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@Lengbumo_mcp-prompt-server.json", "source_file_path": "../mcp_servers/tf_1013.@Lengbumo_mcp-prompt-server_labeled.json", "source_filename": "tf_1013.@Lengbumo_mcp-prompt-server_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 991}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 2}, "min_distance": 1.5342384576797485, "duplicate_count": 0, "min_similar_row_id": 6, "tool_analysis": "The `build_mcp_server` tool from Prompt Server enables creating custom prompt-based content generation systems, which can be configured to produce engaging amusement park attraction descriptions. The `gc` tool from Adwords MCP specializes in injecting promotional advertisements into existing content. These tools work together by first establishing a systematic way to generate professional announcements, then enhancing them with targeted promotional messages for other park features to drive cross-selling opportunities.", "cross_tool_workflow": "First, use `build_mcp_server` to create a specialized MCP server with prompt templates designed for generating compelling, energetic descriptions of amusement park attractions suitable for PA system announcements. This establishes the foundational content generation capability. Then, use the `gc` tool to process these generated descriptions and inject humorous yet persuasive promotional advertisements for secondary park features such as food venues, arcades, and other attractions. The workflow creates a complete promotional announcement system that both informs guests about the main attraction while strategically upselling other revenue-generating park amenities."}
{"target_tools": "Sketchup Integration::eval_ruby, Revit Interaction Server::send_code_to_revit", "question": "I've just secured client approval on my SketchUp concept model for a 2,800 sq ft upscale restaurant interior, but I have a tight deadline: I need to present final material costs to the client tomorrow morning, and the contractor needs shop drawings by Friday. The design includes 14 custom banquettes with specific upholstery, a 40-foot feature wall with geometric acoustic panels in three finishes, and intricate herringbone flooring throughout. Can you help me first analyze my SketchUp model to generate a precise material takeoff with cost estimates, then automatically create detailed shop drawings in Revit—including elevations for the feature wall showing panel layouts, sections for the banquette construction details, and a material schedule that matches my SketchUp quantities? I need this to flow directly from my concept model to construction documentation without manually re-entering all the data.", "metadata": {"prompt_id": "00000006", "row_id": 6, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "27-1025.00", "occupation_title": "Interior Designers", "sampled_tools": [{"server_idx": 714, "tool_idx": 13, "tool_name": "send_code_to_revit", "server_name": "Revit Interaction Server"}, {"server_idx": 708, "tool_idx": 9, "tool_name": "eval_ruby", "server_name": "Sketchup Integration"}], "mcp_servers": [{"server_id": 942, "server_name": "Revit Interaction Server", "rank_by_usage": 943, "server_info": {"id": 942, "name": "Revit Interaction Server", "author": "@ideook/revit-mcp", "overview": "Enable AI to interact with Revit projects by retrieving data and driving Revit to create, modify, or delete elements. Send AI-generated code to Revit for execution to automate design workflows. Enhance productivity by integrating Revit with MCP-supported clients for seamless AI-driven project management.", "repository_url": "https://github.com/ideook/revit-mcp", "homepage": "https://smithery.ai/server/@ideook/revit-mcp", "remote_or_local": "Remote", "license": "MIT", "usage_count": "3", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@ideook/revit-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@ideook/revit-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@ideook/revit-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "ai_element_filter", "description": "An intelligent Revit element querying tool designed specifically for AI assistants to retrieve detailed element information from Revit projects. This tool allows the AI to request elements matching specific criteria (such as category, type, visibility, or spatial location) and then perform further analysis on the returned data to answer complex user queries about Revit model elements. Example: When a user asks 'Find all walls taller than 5m in the project', the AI would: 1) Call this tool with parameters: {\"filterCategory\": \"OST_Walls\", \"includeInstances\": true}, 2) Receive detailed information about all wall instances in the project, 3) Process the returned data to filter walls with height > 5000mm, 4) Present the filtered results to the user with relevant details.", "input_schema": {"type": "object", "properties": {"data": {"type": "object", "properties": {"filterCategory": {"type": "string", "description": "Enumeration of built-in element categories in Revit used for filtering and identifying specific element types (e.g., OST_Walls, OST_Floors, OST_GenericModel). Note that furniture elements may be classified as either OST_Furniture or OST_GenericModel categories, requiring flexible selection approaches"}, "filterElementType": {"type": "string", "description": "The Revit element type name used for filtering specific elements by their class or type (e.g., 'Wall', 'Floor', 'Autodesk.Revit.DB.Wall'). Gets or sets the name of the Revit element type to be filtered."}, "filterFamilySymbolId": {"type": "number", "description": "The ElementId of a specific FamilySymbol (type) in Revit used for filtering elements by their type (e.g., '123456', '789012'). Gets or sets the ElementId of the FamilySymbol to be used as a filter criterion. Use '-1' if no specific FamilySymbol filtering is needed."}, "includeTypes": {"type": "boolean", "default": false, "description": "Determines whether to include element types (such as wall types, door types, etc.) in the selection results. When set to true, element types will be included; when false, they will be excluded."}, "includeInstances": {"type": "boolean", "default": true, "description": "Determines whether to include element instances (such as placed walls, doors, etc.) in the selection results. When set to true, element instances will be included; when false, they will be excluded."}, "filterVisibleInCurrentView": {"type": "boolean", "description": "Determines whether to only return elements that are visible in the current view. When set to true, only elements visible in the current view will be returned. Note: This filter only applies to element instances, not type elements."}, "boundingBoxMin": {"type": "object", "properties": {"p0": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of start point"}, "y": {"type": "number", "description": "Y coordinate of start point"}, "z": {"type": "number", "description": "Z coordinate of start point"}}, "required": ["x", "y", "z"], "additionalProperties": false}, "p1": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of end point"}, "y": {"type": "number", "description": "Y coordinate of end point"}, "z": {"type": "number", "description": "Z coordinate of end point"}}, "required": ["x", "y", "z"], "additionalProperties": false}}, "required": ["p0", "p1"], "additionalProperties": false, "description": "The minimum point coordinates (in mm) for spatial bounding box filtering. When set along with boundingBoxMax, only elements that intersect with this bounding box will be returned. Set to null to disable this filter."}, "boundingBoxMax": {"type": "object", "properties": {"p0": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of start point"}, "y": {"type": "number", "description": "Y coordinate of start point"}, "z": {"type": "number", "description": "Z coordinate of start point"}}, "required": ["x", "y", "z"], "additionalProperties": false}, "p1": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of end point"}, "y": {"type": "number", "description": "Y coordinate of end point"}, "z": {"type": "number", "description": "Z coordinate of end point"}}, "required": ["x", "y", "z"], "additionalProperties": false}}, "required": ["p0", "p1"], "additionalProperties": false, "description": "The maximum point coordinates (in mm) for spatial bounding box filtering. When set along with boundingBoxMin, only elements that intersect with this bounding box will be returned. Set to null to disable this filter."}, "maxElements": {"type": "number", "description": "The maximum number of elements to find in a single tool invocation. Default is 50. Values exceeding 50 are not recommended for performance reasons."}}, "additionalProperties": false, "description": "Configuration parameters for the Revit element filter tool. These settings determine which elements will be selected from the Revit project based on various filtering criteria. Multiple filters can be combined to achieve precise element selection. All spatial coordinates should be provided in millimeters."}}, "required": ["data"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "color_elements", "description": "Color elements in the current view based on a category and parameter value. Each unique parameter value gets assigned a distinct color.", "input_schema": {"type": "object", "properties": {"categoryName": {"type": "string", "description": "The name of the Revit category to color (e.g., 'Walls', 'Doors', 'Rooms')"}, "parameterName": {"type": "string", "description": "The name of the parameter to use for grouping and coloring elements"}, "useGradient": {"type": "boolean", "default": false, "description": "Whether to use a gradient color scheme instead of random colors"}, "customColors": {"type": "array", "items": {"type": "object", "properties": {"r": {"type": "integer", "minimum": 0, "maximum": 255}, "g": {"type": "integer", "minimum": 0, "maximum": 255}, "b": {"type": "integer", "minimum": 0, "maximum": 255}}, "required": ["r", "g", "b"], "additionalProperties": false}, "description": "Optional array of custom RGB colors to use for specific parameter values"}}, "required": ["categoryName", "parameterName"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "create_line_based_element", "description": "Create one or more line-based elements in Revit such as walls, beams, or pipes. Supports batch creation with detailed parameters including family type ID, start and end points, thickness, height, and level information. All units are in millimeters (mm).", "input_schema": {"type": "object", "properties": {"data": {"type": "array", "items": {"type": "object", "properties": {"name": {"type": "string", "description": "Description of the element (e.g., wall, beam)"}, "typeId": {"type": "number", "description": "The ID of the family type to create."}, "locationLine": {"type": "object", "properties": {"p0": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of start point"}, "y": {"type": "number", "description": "Y coordinate of start point"}, "z": {"type": "number", "description": "Z coordinate of start point"}}, "required": ["x", "y", "z"], "additionalProperties": false}, "p1": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of end point"}, "y": {"type": "number", "description": "Y coordinate of end point"}, "z": {"type": "number", "description": "Z coordinate of end point"}}, "required": ["x", "y", "z"], "additionalProperties": false}}, "required": ["p0", "p1"], "additionalProperties": false, "description": "The line defining the element's location"}, "thickness": {"type": "number", "description": "Thickness/width of the element (e.g., wall thickness)"}, "height": {"type": "number", "description": "Height of the element (e.g., wall height)"}, "baseLevel": {"type": "number", "description": "Base level height"}, "baseOffset": {"type": "number", "description": "Offset from the base level"}}, "required": ["name", "locationLine", "thickness", "height", "baseLevel", "baseOffset"], "additionalProperties": false}, "description": "Array of line-based elements to create"}}, "required": ["data"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "create_point_based_element", "description": "Create one or more point-based elements in Revit such as doors, windows, or furniture. Supports batch creation with detailed parameters including family type ID, position, dimensions, and level information. All units are in millimeters (mm).", "input_schema": {"type": "object", "properties": {"data": {"type": "array", "items": {"type": "object", "properties": {"name": {"type": "string", "description": "Description of the element (e.g., door, window)"}, "typeId": {"type": "number", "description": "The ID of the family type to create."}, "locationPoint": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate"}, "y": {"type": "number", "description": "Y coordinate"}, "z": {"type": "number", "description": "Z coordinate"}}, "required": ["x", "y", "z"], "additionalProperties": false, "description": "The position coordinates where the element will be placed"}, "width": {"type": "number", "description": "Width of the element in mm"}, "depth": {"type": "number", "description": "Depth of the element in mm"}, "height": {"type": "number", "description": "Height of the element in mm"}, "baseLevel": {"type": "number", "description": "Base level height"}, "baseOffset": {"type": "number", "description": "Offset from the base level"}, "rotation": {"type": "number", "description": "Rotation angle in degrees (0-360)"}}, "required": ["name", "locationPoint", "width", "height", "baseLevel", "baseOffset"], "additionalProperties": false}, "description": "Array of point-based elements to create"}}, "required": ["data"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "create_surface_based_element", "description": "Create one or more surface-based elements in Revit such as floors, ceilings, or roofs. Supports batch creation with detailed parameters including family type ID, boundary lines, thickness, and level information. All units are in millimeters (mm).", "input_schema": {"type": "object", "properties": {"data": {"type": "array", "items": {"type": "object", "properties": {"name": {"type": "string", "description": "Description of the element (e.g., floor, ceiling)"}, "typeId": {"type": "number", "description": "The ID of the family type to create."}, "boundary": {"type": "object", "properties": {"outerLoop": {"type": "array", "items": {"type": "object", "properties": {"p0": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of start point"}, "y": {"type": "number", "description": "Y coordinate of start point"}, "z": {"type": "number", "description": "Z coordinate of start point"}}, "required": ["x", "y", "z"], "additionalProperties": false}, "p1": {"type": "object", "properties": {"x": {"type": "number", "description": "X coordinate of end point"}, "y": {"type": "number", "description": "Y coordinate of end point"}, "z": {"type": "number", "description": "Z coordinate of end point"}}, "required": ["x", "y", "z"], "additionalProperties": false}}, "required": ["p0", "p1"], "additionalProperties": false}, "minItems": 3, "description": "Array of line segments defining the boundary"}}, "required": ["outerLoop"], "additionalProperties": false, "description": "Boundary definition with outer loop"}, "thickness": {"type": "number", "description": "Thickness of the element"}, "baseLevel": {"type": "number", "description": "Base level height"}, "baseOffset": {"type": "number", "description": "Offset from the base level"}}, "required": ["name", "boundary", "thickness", "baseLevel", "baseOffset"], "additionalProperties": false}, "description": "Array of surface-based elements to create"}}, "required": ["data"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "delete_element", "description": "Delete one or more elements from the Revit model by their element IDs.", "input_schema": {"type": "object", "properties": {"elementIds": {"type": "array", "items": {"type": "string"}, "description": "The IDs of the elements to delete"}}, "required": ["elementIds"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "get_available_family_types", "description": "Get available family types in the current Revit project. You can filter by category and family name, and limit the number of returned types.", "input_schema": {"type": "object", "properties": {"categoryList": {"type": "array", "items": {"type": "string"}, "description": "List of Revit category names to filter by (e.g., 'OST_Walls', 'OST_Doors', 'OST_Furniture')"}, "familyNameFilter": {"type": "string", "description": "Filter family types by family name (partial match)"}, "limit": {"type": "number", "description": "Maximum number of family types to return"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "get_current_document_info", "description": "获取 Revit 当前活动视图的详细信息，包括视图类型、名称、比例等属性。", "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "get_current_view_elements", "description": "Get elements from the current active view in Revit. You can filter by model categories (like Walls, Floors) or annotation categories (like Dimensions, Text). Use includeHidden to show/hide invisible elements and limit to control the number of returned elements.", "input_schema": {"type": "object", "properties": {"modelCategoryList": {"type": "array", "items": {"type": "string"}, "description": "List of Revit model category names (e.g., 'OST_Walls', 'OST_Doors', 'OST_Floors')"}, "annotationCategoryList": {"type": "array", "items": {"type": "string"}, "description": "List of Revit annotation category names (e.g., 'OST_Dimensions', 'OST_WallTags', 'OST_TextNotes')"}, "includeHidden": {"type": "boolean", "description": "Whether to include hidden elements in the results"}, "limit": {"type": "number", "description": "Maximum number of elements to return"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "get_current_view_info", "description": "获取 Revit 当前活动视图的详细信息，包括视图类型、名称、比例等属性。", "input_schema": {"type": "object", "properties": {}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "get_selected_elements", "description": "Get elements currently selected in Revit. You can limit the number of returned elements.", "input_schema": {"type": "object", "properties": {"limit": {"type": "number", "description": "Maximum number of elements to return"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "open_document", "description": "Open Document", "input_schema": {"type": "object", "properties": {"filePath": {"type": "string", "description": "File Path"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "operate_element", "description": "Operate on Revit elements by performing actions such as select, selectionBox, setColor, setTransparency, delete, hide, etc.", "input_schema": {"type": "object", "properties": {"data": {"type": "object", "properties": {"elementIds": {"type": "array", "items": {"type": "number", "description": "A valid Revit element ID to operate on"}, "description": "Array of Revit element IDs to perform the specified action on"}, "action": {"type": "string", "description": "The operation to perform on elements. Valid values: Select, SelectionBox, SetColor, SetTransparency, Delete, Hide, TempHide, Isolate, Unhide, ResetIsolate, Highlight. Select enables direct element selection in the active view. SelectionBox allows selection of elements by drawing a rectangular window in the view. SetColor changes the color of elements (requires elementColor parameter). SetTransparency adjusts element transparency (requires transparencyValue parameter). Highlight is a convenience operation that sets elements to red color (internally calls SetColor with red). Delete permanently removes elements from the project. Hide makes elements invisible in the current view until explicitly shown. TempHide temporarily hides elements in the current view. Isolate displays only selected elements while hiding all others. Unhide reveals previously hidden elements. ResetIsolate restores normal visibility to the view."}, "transparencyValue": {"type": "number", "default": 50, "description": "Transparency value (0-100) for SetTransparency action. Higher values increase transparency."}, "colorValue": {"type": "array", "items": {"type": "number"}, "default": [255, 0, 0], "description": "RGB color values for SetColor action. Default is red [255,0,0]."}}, "required": ["elementIds", "action"], "additionalProperties": false, "description": "Parameters for operating on Revit elements with specific actions"}}, "required": ["data"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "send_code_to_revit", "description": "Send C# code to Revit for execution. The code will be inserted into a template with access to the Revit Document and parameters. Your code should be written to work within the Execute method of the template.", "input_schema": {"type": "object", "properties": {"code": {"type": "string", "description": "The C# code to execute in Revit. This code will be inserted into the Execute method of a template with access to Document and parameters."}, "parameters": {"type": "array", "description": "Optional execution parameters that will be passed to your code"}}, "required": ["code"], "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}, {"name": "tag_all_walls", "description": "Create tags for all walls in the current active view. Tags will be placed at the middle point of each wall.", "input_schema": {"type": "object", "properties": {"useLeader": {"type": "boolean", "default": false, "description": "Whether to use a leader line when creating the tags"}, "tagTypeId": {"type": "string", "description": "The ID of the specific wall tag family type to use. If not provided, the default wall tag type will be used"}}, "additionalProperties": false, "$schema": "http://json-schema.org/draft-07/schema#"}, "annotations": {}}], "tool_count": 15, "tool_names": ["ai_element_filter", "color_elements", "create_line_based_element", "create_point_based_element", "create_surface_based_element", "delete_element", "get_available_family_types", "get_current_document_info", "get_current_view_elements", "get_current_view_info", "get_selected_elements", "open_document", "operate_element", "send_code_to_revit", "tag_all_walls"]}, "labels": {"analysis": "The MCP Server described is specifically designed to interact with Autodesk Revit, a popular Building Information Modeling (BIM) software. Its core functionality revolves around enabling AI to retrieve data from Revit projects, modify elements within those projects, and automate various design workflows. The tools provided allow for querying elements, creating new elements, coloring elements, deleting elements, and executing custom C# code within the Revit environment. This server essentially bridges AI capabilities with architectural and engineering design processes, streamlining project management and enhancing productivity.", "reasoning": "The primary label is chosen as \"AI/ML Tools\" because the server's primary functionality is to enable AI to interact with and control Revit projects, leveraging tools specifically designed for AI assistants. Secondary labels \"Development Tools\" and \"Database Operations\" are chosen because the server allows sending and executing custom code and interacts with the data structure of Revit models, which is akin to database operations.", "primary_label": "AI/ML Tools", "secondary_labels": ["Development Tools", "Database Operations"], "custom_label": "BIM Automation", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@ideook_revit-mcp.json", "source_file_path": "../mcp_servers/tf_0943.@ideook_revit-mcp_labeled.json", "source_filename": "tf_0943.@ideook_revit-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 922}, {"server_id": 906, "server_name": "Sketchup Integration", "rank_by_usage": 907, "server_info": {"id": 906, "name": "Sketchup Integration", "author": "@mhyrr/sketchup-mcp", "overview": "Connect Claude AI to Sketchup for prompt-assisted 3D modeling and scene manipulation. Control components, materials, and execute Ruby code directly within Sketchup to enhance your design workflow.", "repository_url": "https://github.com/mhyrr/sketchup-mcp", "homepage": "https://smithery.ai/server/@mhyrr/sketchup-mcp", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "4", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "create_component", "description": "Create a new component in Sketchup", "input_schema": {"properties": {"type": {"default": "cube", "title": "Type", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "dimensions": {"default": null, "items": {"type": "number"}, "title": "Dimensions", "type": "array"}}, "title": "create_componentArguments", "type": "object"}, "annotations": null}, {"name": "delete_component", "description": "Delete a component by ID", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}}, "required": ["id"], "title": "delete_componentArguments", "type": "object"}, "annotations": null}, {"name": "transform_component", "description": "Transform a component's position, rotation, or scale", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "rotation": {"default": null, "items": {"type": "number"}, "title": "Rotation", "type": "array"}, "scale": {"default": null, "items": {"type": "number"}, "title": "Scale", "type": "array"}}, "required": ["id"], "title": "transform_componentArguments", "type": "object"}, "annotations": null}, {"name": "get_selection", "description": "Get currently selected components", "input_schema": {"properties": {}, "title": "get_selectionArguments", "type": "object"}, "annotations": null}, {"name": "set_material", "description": "Set material for a component", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "material": {"title": "Material", "type": "string"}}, "required": ["id", "material"], "title": "set_materialArguments", "type": "object"}, "annotations": null}, {"name": "export_scene", "description": "Export the current scene", "input_schema": {"properties": {"format": {"default": "skp", "title": "Format", "type": "string"}}, "title": "export_sceneArguments", "type": "object"}, "annotations": null}, {"name": "create_mortise_tenon", "description": "Create a mortise and tenon joint between two components", "input_schema": {"properties": {"mortise_id": {"title": "Mortise Id", "type": "string"}, "tenon_id": {"title": "Tenon Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["mortise_id", "tenon_id"], "title": "create_mortise_tenonArguments", "type": "object"}, "annotations": null}, {"name": "create_dovetail", "description": "Create a dovetail joint between two components", "input_schema": {"properties": {"tail_id": {"title": "Tail Id", "type": "string"}, "pin_id": {"title": "Pin Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "angle": {"default": 15, "title": "Angle", "type": "number"}, "num_tails": {"default": 3, "title": "Num Tails", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["tail_id", "pin_id"], "title": "create_dovetailArguments", "type": "object"}, "annotations": null}, {"name": "create_finger_joint", "description": "Create a finger joint (box joint) between two components", "input_schema": {"properties": {"board1_id": {"title": "Board1 Id", "type": "string"}, "board2_id": {"title": "Board2 Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "num_fingers": {"default": 5, "title": "Num Fingers", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["board1_id", "board2_id"], "title": "create_finger_jointArguments", "type": "object"}, "annotations": null}, {"name": "eval_ruby", "description": "Evaluate arbitrary Ruby code in Sketchup", "input_schema": {"properties": {"code": {"title": "Code", "type": "string"}}, "required": ["code"], "title": "eval_rubyArguments", "type": "object"}, "annotations": null}], "tool_count": 10, "tool_names": ["create_component", "delete_component", "transform_component", "get_selection", "set_material", "export_scene", "create_mortise_tenon", "create_dovetail", "create_finger_joint", "eval_ruby"]}, "labels": {"analysis": "The MCP Server is designed to integrate with SketchUp, a 3D modeling software, allowing for prompt-assisted 3D modeling and scene manipulation. It provides tools to create, modify, and interact with components, materials, and scene exports through both high-level commands and low-level Ruby code execution. This server enables users to control design workflows programmatically, automating repetitive tasks and facilitating complex modeling operations.", "reasoning": "The primary functionality revolves around 3D modeling and CAD operations, which falls under \"Development Tools\" as it involves scripting and code execution (Ruby) to manipulate design elements. \"Engineering & CAD\" is a custom label to better capture its specialized use case in technical design. \"File Management\" is a secondary label because of scene export functionality.", "primary_label": "Development Tools", "secondary_labels": ["File Management"], "custom_label": "Engineering & CAD", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@mhyrr_sketchup-mcp.json", "source_file_path": "../mcp_servers/tf_0907.@mhyrr_sketchup-mcp_labeled.json", "source_filename": "tf_0907.@mhyrr_sketchup-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 888}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 2}, "min_distance": 1.2450519800186157, "duplicate_count": 0, "min_similar_row_id": 8, "tool_analysis": "The eval_ruby tool from Sketchup Integration enables programmatic analysis of 3D models to extract geometric data, count components, and calculate material quantities—essential for generating precise cost estimates directly from concept designs. The send_code_to_revit tool from Revit Interaction Server facilitates automated creation of detailed construction documentation, including shop drawings, elevations, and sections with annotations. Together, these tools bridge the conceptual design phase with technical documentation: SketchUp provides the design validation and material takeoff capabilities, while Revit delivers the detailed BIM-based drawings contractors need, creating a seamless workflow from client-approved concept to construction-ready documentation.", "cross_tool_workflow": "First, eval_ruby executes in SketchUp to analyze the entire restaurant interior model—calculating surface areas for acoustic wall panels, quantifying custom banquette components, measuring flooring patterns, and generating a comprehensive material schedule with associated costs extracted from component attributes. This produces structured data detailing every material quantity and specification. Then, send_code_to_revit uses this material data to automatically generate detailed shop drawings within Revit by creating elevation views of the feature wall with dimensional annotations, developing section details for custom furniture joinery, establishing material schedules linked to the SketchUp quantities, and populating drawing sheets ready for contractor distribution—all while maintaining design intent from the approved concept model."}
{"target_tools": "Sci-Hub MCP Server::get_paper_metadata, Clear Thought Server::scientificmethod", "question": "I'm an atmospheric sciences professor who just received a media inquiry from a national journalist with a tight deadline. They're asking: \"Can scientists definitively prove that the recent increase in Category 5 Atlantic hurricanes is caused by human-induced climate change, and what does the latest peer-reviewed research actually show?\" I need to provide a response that's both scientifically rigorous and accessible. Could you help me compile a bibliography of the most relevant recent papers (2019-2024) on hurricane intensity and climate attribution, and then structure my answer using proper scientific reasoning that carefully distinguishes between what we can and cannot claim with confidence?", "metadata": {"prompt_id": "00000007", "row_id": 7, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "25-1051.00", "occupation_title": "Atmospheric, Earth, Marine, and Space Sciences Teachers, Postsecondary", "sampled_tools": [{"server_idx": 358, "tool_idx": 4, "tool_name": "get_paper_metadata", "server_name": "Sci-Hub MCP Server"}, {"server_idx": 4, "tool_idx": 8, "tool_name": "scientificmethod", "server_name": "Clear Thought Server"}], "mcp_servers": [{"server_id": 1087, "server_name": "Sci-Hub MCP Server", "rank_by_usage": 1088, "server_info": {"id": 1087, "name": "Sci-Hub MCP Server", "author": "@JackKuo666/sci-hub-mcp-server", "overview": "Enable AI assistants to search, access, and analyze academic papers through Sci-Hub using a simple interface. Retrieve detailed metadata and download full-text PDFs programmatically, enhancing research capabilities for users.", "repository_url": "https://github.com/JackKuo666/Sci-Hub-MCP-Server", "homepage": "https://smithery.ai/server/@JackKuo666/sci-hub-mcp-server", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "1", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nconfig = {\n  \"host\": \"0.0.0.0\",\n  \"port\": 8000\n}\n# Encode config in base64\nconfig_b64 = base64.b64encode(json.dumps(config).encode()).decode()\nsmithery_api_key = \"\"\n\n# Create server URL\nurl = f\"https://server.smithery.ai/@JackKuo666/sci-hub-mcp-server/mcp?config={config_b64}&api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "{\n  \"host\": \"0.0.0.0\",\n  \"port\": 8000\n}", "python_sdk_url": "https://server.smithery.ai/@JackKuo666/sci-hub-mcp-server/mcp?config={config_b64}&api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@JackKuo666/sci-hub-mcp-server/mcp?config=eyJob3N0IjogIjAuMC4wLjAiLCAicG9ydCI6IDgwMDB9&api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "search_scihub_by_doi", "description": "", "input_schema": {"properties": {"doi": {"title": "Doi", "type": "string"}}, "required": ["doi"], "title": "search_scihub_by_doiArguments", "type": "object"}, "annotations": null}, {"name": "search_scihub_by_title", "description": "", "input_schema": {"properties": {"title": {"title": "Title", "type": "string"}}, "required": ["title"], "title": "search_scihub_by_titleArguments", "type": "object"}, "annotations": null}, {"name": "search_scihub_by_keyword", "description": "", "input_schema": {"properties": {"keyword": {"title": "Keyword", "type": "string"}, "num_results": {"default": 10, "title": "Num Results", "type": "integer"}}, "required": ["keyword"], "title": "search_scihub_by_keywordArguments", "type": "object"}, "annotations": null}, {"name": "download_scihub_pdf", "description": "", "input_schema": {"properties": {"pdf_url": {"title": "Pdf Url", "type": "string"}, "output_path": {"title": "Output Path", "type": "string"}}, "required": ["pdf_url", "output_path"], "title": "download_scihub_pdfArguments", "type": "object"}, "annotations": null}, {"name": "get_paper_metadata", "description": "", "input_schema": {"properties": {"doi": {"title": "Doi", "type": "string"}}, "required": ["doi"], "title": "get_paper_metadataArguments", "type": "object"}, "annotations": null}], "tool_count": 5, "tool_names": ["search_scihub_by_doi", "search_scihub_by_title", "search_scihub_by_keyword", "download_scihub_pdf", "get_paper_metadata"]}, "labels": {"analysis": "The MCP Server is designed to facilitate access to academic research papers through Sci-Hub, providing tools to search for papers by DOI, title, or keywords, retrieve metadata, and download full-text PDFs programmatically. Its core functionality centers around enhancing research capabilities by streamlining access to scholarly literature, which is particularly useful for AI assistants and researchers.", "reasoning": "The primary label, Web Search & Research, is chosen because the server's main purpose is to search for and retrieve academic papers, which is a form of research assistance. The secondary label, File Management, is selected because one of the key functionalities is downloading PDFs. While Data Analysis & Processing could be relevant for analyzing the metadata retrieved, it is not the primary focus of the server.", "primary_label": "Web Search & Research", "secondary_labels": ["File Management"], "custom_label": "Academic Research Automation", "is_connected": true, "is_remote_tool_valid": true, "featured_server": false}, "original_file": "../crawler/smithery/@JackKuo666_sci-hub-mcp-server.json", "source_file_path": "../mcp_servers/1088.@JackKuo666_sci-hub-mcp-server_labeled.json", "source_filename": "1088.@JackKuo666_sci-hub-mcp-server_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 1065}, {"server_id": 11, "server_name": "Clear Thought Server", "rank_by_usage": 12, "server_info": {"id": 11, "name": "Clear Thought Server", "author": "@chirag127/clear-thought-mcp-server", "overview": "Provide enhanced problem-solving capabilities by leveraging systematic thinking, mental models, and debugging approaches. Enable structured reasoning and decision-making support for complex challenges. Facilitate integration with MCP-compatible clients for advanced cognitive workflows.", "repository_url": "https://github.com/chirag127/Clear-Thought-MCP-server", "homepage": "https://smithery.ai/server/@chirag127/clear-thought-mcp-server", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "10,325", "success_rate": "98.86%", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@chirag127/clear-thought-mcp-server/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@chirag127/clear-thought-mcp-server/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@chirag127/clear-thought-mcp-server/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "sequentialthinking", "description": "A detailed tool for dynamic and reflective problem-solving through thoughts.\nThis tool helps analyze problems through a flexible thinking process that can adapt and evolve.\nEach thought can build on, question, or revise previous insights as understanding deepens.\n\nWhen to use this tool:\n- Breaking down complex problems into steps\n- Planning and design with room for revision\n- Analysis that might need course correction\n- Problems where the full scope might not be clear initially\n- Problems that require a multi-step solution\n- Tasks that need to maintain context over multiple steps\n- Situations where irrelevant information needs to be filtered out\n\nYou should:\n1. Start with an initial estimate of needed thoughts, but be ready to adjust\n2. Feel free to question or revise previous thoughts\n3. Don't hesitate to add more thoughts if needed, even at the \"end\"\n4. Express uncertainty when present\n5. Mark thoughts that revise previous thinking or branch into new paths\n6. Ignore information that is irrelevant to the current step\n7. Generate a solution hypothesis when appropriate\n8. Verify the hypothesis based on the Chain of Thought steps\n9. Repeat the process until satisfied with the solution\n10. Provide a single, ideally correct answer as the final output\n11. Only set next_thought_needed to false when truly done and a satisfactory answer is reached", "input_schema": {"type": "object", "properties": {"thought": {"type": "string"}, "thoughtNumber": {"type": "number", "minimum": 1}, "totalThoughts": {"type": "number", "minimum": 1}, "nextThoughtNeeded": {"type": "boolean"}, "isRevision": {"type": "boolean"}, "revisesThought": {"type": "number", "minimum": 1}, "branchFromThought": {"type": "number", "minimum": 1}, "branchId": {"type": "string"}, "needsMoreThoughts": {"type": "boolean"}}, "required": ["thought", "thoughtNumber", "totalThoughts", "nextThoughtNeeded"]}, "annotations": null}, {"name": "mentalmodel", "description": "A tool for applying structured mental models to problem-solving.\nSupports various mental models including:\n- First Principles Thinking\n- Opportunity Cost Analysis\n- Error Propagation Understanding\n- Rubber Duck Debugging\n- Pareto Principle\n- Occam's Razor\n\nEach model provides a systematic approach to breaking down and solving problems.", "input_schema": {"type": "object", "properties": {"modelName": {"type": "string", "enum": ["first_principles", "opportunity_cost", "error_propagation", "rubber_duck", "pareto_principle", "occams_razor"]}, "problem": {"type": "string"}, "steps": {"type": "array", "items": {"type": "string"}}, "reasoning": {"type": "string"}, "conclusion": {"type": "string"}}, "required": ["modelName", "problem"]}, "annotations": null}, {"name": "designpattern", "description": "A tool for applying design patterns to software architecture and implementation.\nSupports various design patterns including:\n- Modular Architecture\n- API Integration Patterns\n- State Management\n- Asynchronous Processing\n- Scalability Considerations\n- Security Best Practices\n- Agentic Design Patterns\n\nEach pattern provides a structured approach to solving common design challenges.", "input_schema": {"type": "object", "properties": {"patternName": {"type": "string", "enum": ["modular_architecture", "api_integration", "state_management", "async_processing", "scalability", "security", "agentic_design"]}, "context": {"type": "string"}, "implementation": {"type": "array", "items": {"type": "string"}}, "benefits": {"type": "array", "items": {"type": "string"}}, "tradeoffs": {"type": "array", "items": {"type": "string"}}, "codeExample": {"type": "string"}, "languages": {"type": "array", "items": {"type": "string"}}}, "required": ["patternName", "context"]}, "annotations": null}, {"name": "programmingparadigm", "description": "A tool for applying different programming paradigms to solve problems.\nSupports various programming paradigms including:\n- Imperative Programming\n- Procedural Programming\n- Object-Oriented Programming\n- Functional Programming\n- Declarative Programming\n- Logic Programming\n- Event-Driven Programming\n- Aspect-Oriented Programming\n- Concurrent Programming\n- Reactive Programming\n\nEach paradigm provides a different approach to structuring and executing code.", "input_schema": {"type": "object", "properties": {"paradigmName": {"type": "string", "enum": ["imperative", "procedural", "object_oriented", "functional", "declarative", "logic", "event_driven", "aspect_oriented", "concurrent", "reactive"]}, "problem": {"type": "string"}, "approach": {"type": "array", "items": {"type": "string"}}, "benefits": {"type": "array", "items": {"type": "string"}}, "limitations": {"type": "array", "items": {"type": "string"}}, "codeExample": {"type": "string"}, "languages": {"type": "array", "items": {"type": "string"}}}, "required": ["paradigmName", "problem"]}, "annotations": null}, {"name": "debuggingapproach", "description": "A tool for applying systematic debugging approaches to solve technical issues.\nSupports various debugging methods including:\n- Binary Search\n- Reverse Engineering\n- Divide and Conquer\n- Backtracking\n- Cause Elimination\n- Program Slicing\n\nEach approach provides a structured method for identifying and resolving issues.", "input_schema": {"type": "object", "properties": {"approachName": {"type": "string", "enum": ["binary_search", "reverse_engineering", "divide_conquer", "backtracking", "cause_elimination", "program_slicing"]}, "issue": {"type": "string"}, "steps": {"type": "array", "items": {"type": "string"}}, "findings": {"type": "string"}, "resolution": {"type": "string"}}, "required": ["approachName", "issue"]}, "annotations": null}, {"name": "collaborativereasoning", "description": "A detailed tool for simulating expert collaboration with diverse perspectives.\nThis tool helps models tackle complex problems by coordinating multiple viewpoints.\nIt provides a framework for structured collaborative reasoning and perspective integration.", "input_schema": {"type": "object", "properties": {"topic": {"type": "string"}, "personas": {"type": "array", "items": {"type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}, "expertise": {"type": "array", "items": {"type": "string"}}, "background": {"type": "string"}, "perspective": {"type": "string"}, "biases": {"type": "array", "items": {"type": "string"}}, "communication": {"type": "object", "properties": {"style": {"type": "string"}, "tone": {"type": "string"}}, "required": ["style", "tone"]}}, "required": ["id", "name", "expertise", "background", "perspective", "biases", "communication"]}}, "contributions": {"type": "array", "items": {"type": "object", "properties": {"personaId": {"type": "string"}, "content": {"type": "string"}, "type": {"type": "string", "enum": ["observation", "question", "insight", "concern", "suggestion", "challenge", "synthesis"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "referenceIds": {"type": "array", "items": {"type": "string"}}}, "required": ["personaId", "content", "type", "confidence"]}}, "stage": {"type": "string", "enum": ["problem-definition", "ideation", "critique", "integration", "decision", "reflection"]}, "activePersonaId": {"type": "string"}, "nextPersonaId": {"type": "string"}, "consensusPoints": {"type": "array", "items": {"type": "string"}}, "disagreements": {"type": "array", "items": {"type": "object", "properties": {"topic": {"type": "string"}, "positions": {"type": "array", "items": {"type": "object", "properties": {"personaId": {"type": "string"}, "position": {"type": "string"}, "arguments": {"type": "array", "items": {"type": "string"}}}, "required": ["personaId", "position", "arguments"]}}}, "required": ["topic", "positions"]}}, "keyInsights": {"type": "array", "items": {"type": "string"}}, "openQuestions": {"type": "array", "items": {"type": "string"}}, "finalRecommendation": {"type": "string"}, "sessionId": {"type": "string", "description": "Unique identifier for this collaboration session"}, "iteration": {"type": "number", "minimum": 0, "description": "Current iteration of the collaboration"}, "suggestedContributionTypes": {"type": "array", "items": {"type": "string", "enum": ["observation", "question", "insight", "concern", "suggestion", "challenge", "synthesis"]}}, "nextContributionNeeded": {"type": "boolean", "description": "Whether another contribution is needed"}}, "required": ["topic", "personas", "contributions", "stage", "activePersonaId", "sessionId", "iteration", "nextContributionNeeded"]}, "annotations": null}, {"name": "decisionframework", "description": "A detailed tool for structured decision analysis and rational choice.\nThis tool helps models systematically evaluate options, criteria, and outcomes.\nIt supports multiple decision frameworks, probability estimates, and value judgments.", "input_schema": {"type": "object", "properties": {"decisionStatement": {"type": "string"}, "options": {"type": "array", "items": {"type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}, "description": {"type": "string"}}, "required": ["name", "description"]}}, "criteria": {"type": "array", "items": {"type": "object", "properties": {"id": {"type": "string"}, "name": {"type": "string"}, "description": {"type": "string"}, "weight": {"type": "number", "minimum": 0, "maximum": 1}}, "required": ["name", "description", "weight"]}}, "analysisType": {"type": "string", "enum": ["pros-cons", "weighted-criteria", "decision-tree", "expected-value", "scenario-analysis"]}, "stage": {"type": "string", "enum": ["problem-definition", "options-generation", "criteria-definition", "evaluation", "sensitivity-analysis", "decision"]}, "stakeholders": {"type": "array", "items": {"type": "string"}}, "constraints": {"type": "array", "items": {"type": "string"}}, "timeHorizon": {"type": "string"}, "riskTolerance": {"type": "string", "enum": ["risk-averse", "risk-neutral", "risk-seeking"]}, "possibleOutcomes": {"type": "array", "items": {"type": "object", "properties": {"id": {"type": "string"}, "description": {"type": "string"}, "probability": {"type": "number", "minimum": 0, "maximum": 1}, "value": {"type": "number"}, "optionId": {"type": "string"}, "confidenceInEstimate": {"type": "number", "minimum": 0, "maximum": 1}}, "required": ["description", "probability", "optionId", "value", "confidenceInEstimate"]}}, "recommendation": {"type": "string"}, "rationale": {"type": "string"}, "decisionId": {"type": "string", "description": "Unique identifier for this decision analysis"}, "iteration": {"type": "number", "minimum": 0, "description": "Current iteration of the decision process"}, "nextStageNeeded": {"type": "boolean", "description": "Whether another stage is needed in the process"}}, "required": ["decisionStatement", "options", "analysisType", "stage", "decisionId", "iteration", "nextStageNeeded"]}, "annotations": null}, {"name": "metacognitivemonitoring", "description": "A detailed tool for systematic self-monitoring of knowledge and reasoning quality.\nThis tool helps models track knowledge boundaries, claim certainty, and reasoning biases.\nIt provides a framework for metacognitive assessment across various domains and reasoning tasks.", "input_schema": {"type": "object", "properties": {"task": {"type": "string"}, "stage": {"type": "string", "enum": ["knowledge-assessment", "planning", "execution", "monitoring", "evaluation", "reflection"]}, "knowledgeAssessment": {"type": "object", "properties": {"domain": {"type": "string"}, "knowledgeLevel": {"type": "string", "enum": ["expert", "proficient", "familiar", "basic", "minimal", "none"]}, "confidenceScore": {"type": "number", "minimum": 0, "maximum": 1}, "supportingEvidence": {"type": "string"}, "knownLimitations": {"type": "array", "items": {"type": "string"}}, "relevantTrainingCutoff": {"type": "string"}}, "required": ["domain", "knowledgeLevel", "confidenceScore", "supportingEvidence", "knownLimitations"]}, "claims": {"type": "array", "items": {"type": "object", "properties": {"claim": {"type": "string"}, "status": {"type": "string", "enum": ["fact", "inference", "speculation", "uncertain"]}, "confidenceScore": {"type": "number", "minimum": 0, "maximum": 1}, "evidenceBasis": {"type": "string"}, "falsifiabilityCriteria": {"type": "string"}, "alternativeInterpretations": {"type": "array", "items": {"type": "string"}}}, "required": ["claim", "status", "confidenceScore", "evidenceBasis"]}}, "reasoningSteps": {"type": "array", "items": {"type": "object", "properties": {"step": {"type": "string"}, "potentialBiases": {"type": "array", "items": {"type": "string"}}, "assumptions": {"type": "array", "items": {"type": "string"}}, "logicalValidity": {"type": "number", "minimum": 0, "maximum": 1}, "inferenceStrength": {"type": "number", "minimum": 0, "maximum": 1}}, "required": ["step", "potentialBiases", "assumptions", "logicalValidity", "inferenceStrength"]}}, "overallConfidence": {"type": "number", "minimum": 0, "maximum": 1}, "uncertaintyAreas": {"type": "array", "items": {"type": "string"}}, "recommendedApproach": {"type": "string"}, "monitoringId": {"type": "string", "description": "Unique identifier for this monitoring session"}, "iteration": {"type": "number", "minimum": 0, "description": "Current iteration of the monitoring process"}, "suggestedAssessments": {"type": "array", "items": {"type": "string", "enum": ["knowledge", "claim", "reasoning", "overall"]}}, "nextAssessmentNeeded": {"type": "boolean", "description": "Whether further assessment is needed"}}, "required": ["task", "stage", "overallConfidence", "uncertaintyAreas", "recommendedApproach", "monitoringId", "iteration", "nextAssessmentNeeded"]}, "annotations": null}, {"name": "scientificmethod", "description": "A detailed tool for applying formal scientific reasoning to questions and problems.\nThis tool guides models through the scientific method with structured hypothesis testing.\nIt enforces explicit variable identification, prediction making, and evidence evaluation.", "input_schema": {"type": "object", "properties": {"stage": {"type": "string", "enum": ["observation", "question", "hypothesis", "experiment", "analysis", "conclusion", "iteration"]}, "observation": {"type": "string"}, "question": {"type": "string"}, "hypothesis": {"type": "object", "properties": {"statement": {"type": "string"}, "variables": {"type": "array", "items": {"type": "object", "properties": {"name": {"type": "string"}, "type": {"type": "string", "enum": ["independent", "dependent", "controlled", "confounding"]}, "operationalization": {"type": "string"}}, "required": ["name", "type"]}}, "assumptions": {"type": "array", "items": {"type": "string"}}, "hypothesisId": {"type": "string"}, "confidence": {"type": "number", "minimum": 0, "maximum": 1}, "domain": {"type": "string"}, "iteration": {"type": "number", "minimum": 0}, "alternativeTo": {"type": "array", "items": {"type": "string"}}, "refinementOf": {"type": "string"}, "status": {"type": "string", "enum": ["proposed", "testing", "supported", "refuted", "refined"]}}, "required": ["statement", "variables", "assumptions", "hypothesisId", "confidence", "domain", "iteration", "status"]}, "experiment": {"type": "object", "properties": {"design": {"type": "string"}, "methodology": {"type": "string"}, "predictions": {"type": "array", "items": {"type": "object", "properties": {"if": {"type": "string"}, "then": {"type": "string"}, "else": {"type": "string"}}, "required": ["if", "then"]}}, "experimentId": {"type": "string"}, "hypothesisId": {"type": "string"}, "controlMeasures": {"type": "array", "items": {"type": "string"}}, "results": {"type": "string"}, "outcomeMatched": {"type": "boolean"}, "unexpectedObservations": {"type": "array", "items": {"type": "string"}}, "limitations": {"type": "array", "items": {"type": "string"}}, "nextSteps": {"type": "array", "items": {"type": "string"}}}, "required": ["design", "methodology", "predictions", "experimentId", "hypothesisId", "controlMeasures"]}, "analysis": {"type": "string"}, "conclusion": {"type": "string"}, "inquiryId": {"type": "string", "description": "Unique identifier for this scientific inquiry"}, "iteration": {"type": "number", "minimum": 0, "description": "Current iteration of the scientific process"}, "nextStageNeeded": {"type": "boolean", "description": "Whether another stage is needed in the process"}}, "required": ["stage", "inquiryId", "iteration", "nextStageNeeded"]}, "annotations": null}, {"name": "structuredargumentation", "description": "A detailed tool for systematic dialectical reasoning and argument analysis.\nThis tool helps analyze complex questions through formal argumentation structures.\nIt facilitates the creation, critique, and synthesis of competing arguments.", "input_schema": {"type": "object", "properties": {"claim": {"type": "string"}, "premises": {"type": "array", "items": {"type": "string"}}, "conclusion": {"type": "string"}, "argumentId": {"type": "string", "description": "Optional unique identifier for this argument"}, "argumentType": {"type": "string", "enum": ["thesis", "antithesis", "synthesis", "objection", "rebuttal"]}, "confidence": {"type": "number", "minimum": 0, "maximum": 1, "description": "Confidence level in this argument (0.0-1.0)"}, "respondsTo": {"type": "string", "description": "ID of the argument this directly responds to"}, "supports": {"type": "array", "items": {"type": "string"}, "description": "IDs of arguments this supports"}, "contradicts": {"type": "array", "items": {"type": "string"}, "description": "IDs of arguments this contradicts"}, "strengths": {"type": "array", "items": {"type": "string"}, "description": "Notable strong points of the argument"}, "weaknesses": {"type": "array", "items": {"type": "string"}, "description": "Notable weak points of the argument"}, "nextArgumentNeeded": {"type": "boolean", "description": "Whether another argument is needed in the dialectic"}, "suggestedNextTypes": {"type": "array", "items": {"type": "string", "enum": ["thesis", "antithesis", "synthesis", "objection", "rebuttal"]}, "description": "Suggested types for the next argument"}}, "required": ["claim", "premises", "conclusion", "argumentType", "confidence", "nextArgumentNeeded"]}, "annotations": null}, {"name": "visualreasoning", "description": "A tool for visual thinking, problem-solving, and communication.\nThis tool enables models to create, manipulate, and interpret diagrams, graphs, and other visual representations.\nIt supports various visual elements and operations to facilitate insight generation and hypothesis testing.", "input_schema": {"type": "object", "properties": {"operation": {"type": "string", "enum": ["create", "update", "delete", "transform", "observe"]}, "elements": {"type": "array", "items": {"type": "object", "properties": {"id": {"type": "string"}, "type": {"type": "string", "enum": ["node", "edge", "container", "annotation"]}, "label": {"type": "string"}, "properties": {"type": "object", "additionalProperties": true}, "source": {"type": "string"}, "target": {"type": "string"}, "contains": {"type": "array", "items": {"type": "string"}}}, "required": ["id", "type", "properties"]}}, "transformationType": {"type": "string", "enum": ["rotate", "move", "resize", "recolor", "regroup"]}, "diagramId": {"type": "string"}, "diagramType": {"type": "string", "enum": ["graph", "flowchart", "stateDiagram", "conceptMap", "treeDiagram", "custom"]}, "iteration": {"type": "number", "minimum": 0}, "observation": {"type": "string"}, "insight": {"type": "string"}, "hypothesis": {"type": "string"}, "nextOperationNeeded": {"type": "boolean"}}, "required": ["operation", "diagramId", "diagramType", "iteration", "nextOperationNeeded"]}, "annotations": null}], "tool_count": 11, "tool_names": ["sequentialthinking", "mentalmodel", "designpattern", "programmingparadigm", "debuggingapproach", "collaborativereasoning", "decisionframework", "metacognitivemonitoring", "scientificmethod", "structuredargumentation", "visualreasoning"]}, "labels": {"analysis": "The Clear Thought Server is designed to enhance problem-solving capabilities through systematic thinking, structured reasoning, and mental models. Its tools facilitate structured analysis, collaborative reasoning, debugging, decision-making, and various programming/design approaches. The server specializes in tackling complex challenges by breaking them down into manageable steps, verifying hypotheses, and ensuring rigorous logical flow. It also supports metacognitive monitoring, scientific reasoning, and visual problem-solving, making it a versatile tool for advanced cognitive workflows.", "reasoning": "The primary label \"AI/ML Tools\" was chosen because the server's core functionality revolves around structured reasoning, problem-solving, and cognitive enhancement — all key aspects of AI/ML applications. Secondary labels \"Development Tools\" and \"Operating System\" were selected because of the server's emphasis on programming paradigms, design patterns, and systematic debugging, which are essential for software development and problem-solving within technical systems. The custom label \"Structured Reasoning\" was added to highlight the server's unique emphasis on systematic, multi-step problem-solving approaches.", "primary_label": "AI/ML Tools", "secondary_labels": ["Development Tools", "Operating System"], "custom_label": "Structured Reasoning", "is_connected": true, "is_remote_tool_valid": true, "featured_server": false}, "original_file": "../crawler/smithery/@chirag127_clear-thought-mcp-server.json", "source_file_path": "../mcp_servers/0012.@chirag127_clear-thought-mcp-server_labeled.json", "source_filename": "0012.@chirag127_clear-thought-mcp-server_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 12}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 2}, "min_distance": 1.655170202255249, "duplicate_count": 0, "min_similar_row_id": 0, "tool_analysis": "The two tools create a powerful research-to-response pipeline for scientific communication. The Sci-Hub tool provides evidence-gathering capabilities by retrieving current research metadata on specialized topics, essential for compiling authoritative bibliographies. The Clear Thought scientific method tool then transforms that raw research into structured, logically rigorous analysis with explicit hypothesis testing and evidence evaluation. Together they enable a complete workflow: from literature review to scientifically sound communication, ensuring both factual backing and methodological integrity when addressing complex public questions.", "cross_tool_workflow": "The teacher first uses the Sci-Hub tool to search for recent papers (2019-2024) on hurricane intensity attribution and climate change, extracting metadata and key findings. This creates an evidence base and bibliography. Next, the teacher feeds the core research findings into the scientific method tool, which structures a response by: (1) defining the specific question and identifying variables (natural variability, anthropogenic forcing, detection limits), (2) formulating testable hypotheses about causation vs. correlation, (3) evaluating the compiled paper evidence with appropriate confidence levels and uncertainty quantification, and (4) generating a nuanced conclusion that addresses the journalist's question while maintaining scientific rigor and avoiding overstatement."}
{"target_tools": "Sketchup Integration::eval_ruby, Sketchup Integration::set_material", "question": "I'm restoring a historic building and need to recreate missing ornamental plaster crown molding. The architect specified it must be 6 inches tall with an acanthus leaf pattern repeating every 12 inches along a 20-foot wall section. Can you help me first create the custom 3D geometry for this molding component in SketchUp, then apply a realistic historic lime plaster material to it so I can show the client and calculate exact material needs?", "metadata": {"prompt_id": "00000008", "row_id": 8, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "47-2161.00", "occupation_title": "Plasterers and Stucco Masons", "sampled_tools": [{"server_idx": 708, "tool_idx": 4, "tool_name": "set_material", "server_name": "Sketchup Integration"}, {"server_idx": 708, "tool_idx": 9, "tool_name": "eval_ruby", "server_name": "Sketchup Integration"}], "mcp_servers": [{"server_id": 906, "server_name": "Sketchup Integration", "rank_by_usage": 907, "server_info": {"id": 906, "name": "Sketchup Integration", "author": "@mhyrr/sketchup-mcp", "overview": "Connect Claude AI to Sketchup for prompt-assisted 3D modeling and scene manipulation. Control components, materials, and execute Ruby code directly within Sketchup to enhance your design workflow.", "repository_url": "https://github.com/mhyrr/sketchup-mcp", "homepage": "https://smithery.ai/server/@mhyrr/sketchup-mcp", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "4", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@mhyrr/sketchup-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "create_component", "description": "Create a new component in Sketchup", "input_schema": {"properties": {"type": {"default": "cube", "title": "Type", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "dimensions": {"default": null, "items": {"type": "number"}, "title": "Dimensions", "type": "array"}}, "title": "create_componentArguments", "type": "object"}, "annotations": null}, {"name": "delete_component", "description": "Delete a component by ID", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}}, "required": ["id"], "title": "delete_componentArguments", "type": "object"}, "annotations": null}, {"name": "transform_component", "description": "Transform a component's position, rotation, or scale", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "position": {"default": null, "items": {"type": "number"}, "title": "Position", "type": "array"}, "rotation": {"default": null, "items": {"type": "number"}, "title": "Rotation", "type": "array"}, "scale": {"default": null, "items": {"type": "number"}, "title": "Scale", "type": "array"}}, "required": ["id"], "title": "transform_componentArguments", "type": "object"}, "annotations": null}, {"name": "get_selection", "description": "Get currently selected components", "input_schema": {"properties": {}, "title": "get_selectionArguments", "type": "object"}, "annotations": null}, {"name": "set_material", "description": "Set material for a component", "input_schema": {"properties": {"id": {"title": "Id", "type": "string"}, "material": {"title": "Material", "type": "string"}}, "required": ["id", "material"], "title": "set_materialArguments", "type": "object"}, "annotations": null}, {"name": "export_scene", "description": "Export the current scene", "input_schema": {"properties": {"format": {"default": "skp", "title": "Format", "type": "string"}}, "title": "export_sceneArguments", "type": "object"}, "annotations": null}, {"name": "create_mortise_tenon", "description": "Create a mortise and tenon joint between two components", "input_schema": {"properties": {"mortise_id": {"title": "Mortise Id", "type": "string"}, "tenon_id": {"title": "Tenon Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["mortise_id", "tenon_id"], "title": "create_mortise_tenonArguments", "type": "object"}, "annotations": null}, {"name": "create_dovetail", "description": "Create a dovetail joint between two components", "input_schema": {"properties": {"tail_id": {"title": "Tail Id", "type": "string"}, "pin_id": {"title": "Pin Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "angle": {"default": 15, "title": "Angle", "type": "number"}, "num_tails": {"default": 3, "title": "Num Tails", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["tail_id", "pin_id"], "title": "create_dovetailArguments", "type": "object"}, "annotations": null}, {"name": "create_finger_joint", "description": "Create a finger joint (box joint) between two components", "input_schema": {"properties": {"board1_id": {"title": "Board1 Id", "type": "string"}, "board2_id": {"title": "Board2 Id", "type": "string"}, "width": {"default": 1, "title": "Width", "type": "number"}, "height": {"default": 1, "title": "Height", "type": "number"}, "depth": {"default": 1, "title": "Depth", "type": "number"}, "num_fingers": {"default": 5, "title": "Num Fingers", "type": "integer"}, "offset_x": {"default": 0, "title": "Offset X", "type": "number"}, "offset_y": {"default": 0, "title": "Offset Y", "type": "number"}, "offset_z": {"default": 0, "title": "Offset Z", "type": "number"}}, "required": ["board1_id", "board2_id"], "title": "create_finger_jointArguments", "type": "object"}, "annotations": null}, {"name": "eval_ruby", "description": "Evaluate arbitrary Ruby code in Sketchup", "input_schema": {"properties": {"code": {"title": "Code", "type": "string"}}, "required": ["code"], "title": "eval_rubyArguments", "type": "object"}, "annotations": null}], "tool_count": 10, "tool_names": ["create_component", "delete_component", "transform_component", "get_selection", "set_material", "export_scene", "create_mortise_tenon", "create_dovetail", "create_finger_joint", "eval_ruby"]}, "labels": {"analysis": "The MCP Server is designed to integrate with SketchUp, a 3D modeling software, allowing for prompt-assisted 3D modeling and scene manipulation. It provides tools to create, modify, and interact with components, materials, and scene exports through both high-level commands and low-level Ruby code execution. This server enables users to control design workflows programmatically, automating repetitive tasks and facilitating complex modeling operations.", "reasoning": "The primary functionality revolves around 3D modeling and CAD operations, which falls under \"Development Tools\" as it involves scripting and code execution (Ruby) to manipulate design elements. \"Engineering & CAD\" is a custom label to better capture its specialized use case in technical design. \"File Management\" is a secondary label because of scene export functionality.", "primary_label": "Development Tools", "secondary_labels": ["File Management"], "custom_label": "Engineering & CAD", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@mhyrr_sketchup-mcp.json", "source_file_path": "../mcp_servers/tf_0907.@mhyrr_sketchup-mcp_labeled.json", "source_filename": "tf_0907.@mhyrr_sketchup-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 888}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 1}, "min_distance": 1.2450519800186157, "duplicate_count": 0, "min_similar_row_id": 6, "tool_analysis": "The `eval_ruby` tool enables programmatic creation of complex ornamental plaster geometries through Ruby scripting, essential for generating parametric crown molding with precise dimensions and repetitive decorative patterns that would be tedious to model manually. The `set_material` tool then applies realistic plaster finishes to these components, which is critical for client visualization and accurate material quantity calculations. Together, they create a complete workflow: automate complex geometry creation followed by professional material application.", "cross_tool_workflow": "First, `eval_ruby` executes custom Ruby code to generate a parametric ornamental plaster crown molding component with specific architectural requirements (6\" height, 12\" acanthus leaf pattern repeat, 20' length). The script creates the detailed 3D geometry, proper component naming, and positioning. Then, `set_material` applies a \"Historic Lime Plaster\" material to the newly created component, enabling realistic rendering for client approval and providing accurate material specifications for takeoff calculations. The output from the Ruby execution (component identification) feeds directly into the material assignment step."}
{"target_tools": "KiCad MCP Server::analyze_schematic_connections, Visual Reasoning Server::visualReasoning", "question": "I'm working on repairing a digital audio mixer for a live sound installation that's experiencing intermittent signal loss on several channels. I've pulled up the KiCad schematic files, but the signal routing through the FPGA, DSP chips, and multiple ADC/DAC stages is pretty complex. I need to trace the complete signal path from the XLR inputs through the processing chain to identify where the signal might be dropping out. Could you help me analyze the schematic connections to map out the signal path, and then create a visual flow diagram that shows the entire signal chain? I need the diagram for both troubleshooting and to update our service manual documentation for future repairs.", "metadata": {"prompt_id": "00000009", "row_id": 9, "mode": "onet_occupation", "question_gen_args": {"num_tools": 2, "total_prompts": 10, "output_folder": "../data", "job_name": null, "timestamp": 1769389186, "seed": null}, "onet_soc_code": "49-2097.00", "occupation_title": "Audiovisual Equipment Installers and Repairers", "sampled_tools": [{"server_idx": 755, "tool_idx": 12, "tool_name": "analyze_schematic_connections", "server_name": "KiCad MCP Server"}, {"server_idx": 156, "tool_idx": 0, "tool_name": "visualReasoning", "server_name": "Visual Reasoning Server"}], "mcp_servers": [{"server_id": 1127, "server_name": "KiCad MCP Server", "rank_by_usage": 1128, "server_info": {"id": 1127, "name": "KiCad MCP Server", "author": "@lamaalrajih/kicad-mcp", "overview": "Set up a server to enhance your KiCad experience. Manage projects, run design rule checks, and visualize PCB layouts seamlessly with any MCP-compliant client. Streamline your PCB design workflow and troubleshoot issues effectively.", "repository_url": "https://github.com/lamaalrajih/kicad-mcp", "homepage": "https://smithery.ai/server/@lamaalrajih/kicad-mcp", "remote_or_local": "Remote", "license": "Smithery", "usage_count": "1", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@lamaalrajih/kicad-mcp/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@lamaalrajih/kicad-mcp/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@lamaalrajih/kicad-mcp/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "list_projects", "description": "Find and list all KiCad projects on this system.", "input_schema": {"properties": {}, "title": "list_projectsArguments", "type": "object"}, "annotations": null}, {"name": "get_project_structure", "description": "Get the structure and files of a KiCad project.", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "get_project_structureArguments", "type": "object"}, "annotations": null}, {"name": "open_project", "description": "Open a KiCad project in KiCad.", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "open_projectArguments", "type": "object"}, "annotations": null}, {"name": "validate_project", "description": "Basic validation of a KiCad project.", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "validate_projectArguments", "type": "object"}, "annotations": null}, {"name": "generate_pcb_thumbnail", "description": "Generate a thumbnail image of a KiCad PCB layout using kicad-cli.\n\n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: Context for MCP communication\n\n        Returns:\n            Thumbnail image of the PCB or None if generation failed\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "generate_pcb_thumbnailArguments", "type": "object"}, "annotations": null}, {"name": "generate_project_thumbnail", "description": "Generate a thumbnail of a KiCad project's PCB layout (Alias for generate_pcb_thumbnail).", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "generate_project_thumbnailArguments", "type": "object"}, "annotations": null}, {"name": "get_drc_history_tool", "description": "Get the DRC check history for a KiCad project.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            \n        Returns:\n            Dictionary with DRC history entries\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "get_drc_history_toolArguments", "type": "object"}, "annotations": null}, {"name": "run_drc_check", "description": "Run a Design Rule Check on a KiCad PCB file.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with DRC results and statistics\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "run_drc_checkArguments", "type": "object"}, "annotations": null}, {"name": "analyze_bom", "description": "Analyze a KiCad project's Bill of Materials.\n        \n        This tool will look for BOM files related to a KiCad project and provide\n        analysis including component counts, categories, and cost estimates if available.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with BOM analysis results\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "analyze_bomArguments", "type": "object"}, "annotations": null}, {"name": "export_bom_csv", "description": "Export a Bill of Materials for a KiCad project.\n        \n        This tool attempts to generate a CSV BOM file for a KiCad project.\n        It requires KiCad to be installed with the appropriate command-line tools.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with export results\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "export_bom_csvArguments", "type": "object"}, "annotations": null}, {"name": "extract_schematic_netlist", "description": "Extract netlist information from a KiCad schematic.\n        \n        This tool parses a KiCad schematic file and extracts comprehensive\n        netlist information including components, connections, and labels.\n        \n        Args:\n            schematic_path: Path to the KiCad schematic file (.kicad_sch)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with netlist information\n        ", "input_schema": {"properties": {"schematic_path": {"title": "Schematic Path", "type": "string"}}, "required": ["schematic_path"], "title": "extract_schematic_netlistArguments", "type": "object"}, "annotations": null}, {"name": "extract_project_netlist", "description": "Extract netlist from a KiCad project's schematic.\n        \n        This tool finds the schematic associated with a KiCad project\n        and extracts its netlist information.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with netlist information\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "extract_project_netlistArguments", "type": "object"}, "annotations": null}, {"name": "analyze_schematic_connections", "description": "Analyze connections in a KiCad schematic.\n        \n        This tool provides detailed analysis of component connections,\n        including power nets, signal paths, and potential issues.\n        \n        Args:\n            schematic_path: Path to the KiCad schematic file (.kicad_sch)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with connection analysis\n        ", "input_schema": {"properties": {"schematic_path": {"title": "Schematic Path", "type": "string"}}, "required": ["schematic_path"], "title": "analyze_schematic_connectionsArguments", "type": "object"}, "annotations": null}, {"name": "find_component_connections", "description": "Find all connections for a specific component in a KiCad project.\n        \n        This tool extracts information about how a specific component\n        is connected to other components in the schematic.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            component_ref: Component reference (e.g., \"R1\", \"U3\")\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with component connection information\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}, "component_ref": {"title": "Component Ref", "type": "string"}}, "required": ["project_path", "component_ref"], "title": "find_component_connectionsArguments", "type": "object"}, "annotations": null}, {"name": "identify_circuit_patterns", "description": "Identify common circuit patterns in a KiCad schematic.\n        \n        This tool analyzes a schematic to recognize common circuit blocks such as:\n        - Power supply circuits (linear regulators, switching converters)\n        - Amplifier circuits (op-amps, transistor amplifiers)\n        - Filter circuits (RC, LC, active filters)\n        - Digital interfaces (I2C, SPI, UART)\n        - Microcontroller circuits\n        - And more\n        \n        Args:\n            schematic_path: Path to the KiCad schematic file (.kicad_sch)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with identified circuit patterns\n        ", "input_schema": {"properties": {"schematic_path": {"title": "Schematic Path", "type": "string"}}, "required": ["schematic_path"], "title": "identify_circuit_patternsArguments", "type": "object"}, "annotations": null}, {"name": "analyze_project_circuit_patterns", "description": "Identify circuit patterns in a KiCad project's schematic.\n        \n        Args:\n            project_path: Path to the KiCad project file (.kicad_pro)\n            ctx: MCP context for progress reporting\n            \n        Returns:\n            Dictionary with identified circuit patterns\n        ", "input_schema": {"properties": {"project_path": {"title": "Project Path", "type": "string"}}, "required": ["project_path"], "title": "analyze_project_circuit_patternsArguments", "type": "object"}, "annotations": null}], "tool_count": 16, "tool_names": ["list_projects", "get_project_structure", "open_project", "validate_project", "generate_pcb_thumbnail", "generate_project_thumbnail", "get_drc_history_tool", "run_drc_check", "analyze_bom", "export_bom_csv", "extract_schematic_netlist", "extract_project_netlist", "analyze_schematic_connections", "find_component_connections", "identify_circuit_patterns", "analyze_project_circuit_patterns"]}, "labels": {"analysis": "The KiCad MCP Server is designed to enhance the workflow for PCB design using the KiCad software suite. It provides tools for project management, schematic analysis, and PCB layout verification. Key functionalities include listing and validating projects, generating visual thumbnails, running design rule checks (DRC), analyzing bill of materials (BOM), extracting netlists, and identifying common circuit patterns. The server appears to act as an intermediary that automates and streamlines various aspects of the PCB design process, making it particularly useful for electronic engineers and hardware developers.", "reasoning": "The primary label \"Electrical Engineering Tools\" was chosen because the server's core functionality revolves around PCB design, schematic analysis, and hardware-related tasks. This is not covered by the predefined categories, hence the creation of a custom label. Secondary labels like \"File Management\" and \"Data Analysis & Processing\" were added because the tools handle project files and perform analysis on schematic and BOM data. No predefined secondary labels were a perfect fit, but these came closest to representing additional aspects of the server's functionality.", "primary_label": "Others", "secondary_labels": ["File Management", "Data Analysis & Processing"], "custom_label": "Electrical Engineering Tools", "is_connected": true, "is_remote_tool_valid": false, "featured_server": false}, "original_file": "../crawler/smithery/@lamaalrajih_kicad-mcp.json", "source_file_path": "../mcp_servers/tf_1128.@lamaalrajih_kicad-mcp_labeled.json", "source_filename": "tf_1128.@lamaalrajih_kicad-mcp_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 1105}, {"server_id": 529, "server_name": "Visual Reasoning Server", "rank_by_usage": 530, "server_info": {"id": 529, "name": "Visual Reasoning Server", "author": "@waldzellai/visual-reasoning", "overview": "Enable language models to perform complex visual and spatial reasoning by creating, manipulating, and iterating on diagrammatic representations such as graphs, flowcharts, and concept maps. Enhance problem-solving capabilities by integrating visual thinking with verbal insights, supporting multi-modal outputs including ASCII art and SVG. Facilitate iterative refinement and pattern recognition through a flexible visual element manipulation system.", "repository_url": "https://github.com/waldzellai/model-enhancement-servers", "homepage": "https://smithery.ai/server/@waldzellai/visual-reasoning", "remote_or_local": "Remote", "license": "MIT", "usage_count": "27", "success_rate": "Not available", "tags": ["search", "web", "api", "mcp"], "categories": ["search", "api"], "python_sdk": "import mcp\nfrom mcp.client.streamable_http import streamablehttp_client\nimport json\nimport base64\n\nsmithery_api_key = \"\"\nurl = f\"https://server.smithery.ai/@waldzellai/visual-reasoning/mcp?api_key={smithery_api_key}\"\n\nasync def main():\n    # Connect to the server using HTTP client\n    async with streamablehttp_client(url) as (read_stream, write_stream, _):\n        async with mcp.ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools_result = await session.list_tools()\n            print(f\"Available tools: {', '.join([t.name for t in tools_result.tools])}\")\n\nif __name__ == \"__main__\":\n    import asyncio\n    asyncio.run(main())", "configuration_schema": "", "smithery_configuration_requirements": [], "python_sdk_config": "", "python_sdk_url": "https://server.smithery.ai/@waldzellai/visual-reasoning/mcp?api_key={smithery_api_key}"}, "remote_server_response": {"url": "https://server.smithery.ai/@waldzellai/visual-reasoning/mcp?api_key={smithery_api_key}&profile={smithery_profile}", "is_success": true, "error": null, "tools": [{"name": "visualReasoning", "description": "A detailed tool for diagrammatic thinking and spatial representation.\nThis tool helps models create and manipulate visual representations of problems.\nIt can be used to develop system diagrams, flowcharts, concept maps, and other visual models.\n\nWhen to use this tool:\n- System architecture design\n- Algorithm visualization\n- Concept mapping and knowledge organization\n- Pattern recognition in complex data\n- Spatial problem solving\n\nKey features:\n- Create and manipulate abstract visual elements\n- Support for multiple visual representation types\n- Track iterations of visual thinking\n- Translate between verbal descriptions and visual representations\n- Generate visual insights from patterns\n\nParameters explained:\n- operation: The type of action to perform (create, update, delete, transform, observe)\n- elements: The visual elements to operate on\n- diagramId: Identifier for the diagram being created or modified\n- diagramType: The type of diagram (graph, flowchart, state diagram, etc.)\n- iteration: The current iteration of the visual reasoning process\n- observation/insight/hypothesis: Verbal reasoning about the visual representation\n- nextOperationNeeded: Whether another operation is needed in the visual reasoning process", "input_schema": {"type": "object", "properties": {"operation": {"type": "string", "enum": ["create", "update", "delete", "transform", "observe"], "description": "The type of operation to perform"}, "elements": {"type": "array", "description": "The visual elements to operate on", "items": {"type": "object", "properties": {"id": {"type": "string", "description": "Unique identifier for the element"}, "type": {"type": "string", "enum": ["node", "edge", "container", "annotation"], "description": "The type of visual element"}, "label": {"type": "string", "description": "Text label for the element"}, "properties": {"type": "object", "description": "Visual properties like position, size, color"}, "source": {"type": "string", "description": "For edges: ID of the source element"}, "target": {"type": "string", "description": "For edges: ID of the target element"}, "contains": {"type": "array", "description": "For containers: IDs of contained elements", "items": {"type": "string"}}}, "required": ["type"]}}, "transformationType": {"type": "string", "enum": ["rotate", "move", "resize", "recolor", "regroup"], "description": "For transform operations: the type of transformation"}, "diagramId": {"type": "string", "description": "Identifier for the diagram"}, "diagramType": {"type": "string", "enum": ["graph", "flowchart", "stateDiagram", "conceptMap", "treeDiagram", "custom"], "description": "The type of diagram being created or modified"}, "iteration": {"type": "number", "description": "Current iteration of the visual reasoning process", "minimum": 0}, "observation": {"type": "string", "description": "Observations about the current visual state"}, "insight": {"type": "string", "description": "Insights derived from the visual representation"}, "hypothesis": {"type": "string", "description": "Hypotheses based on the visual pattern"}, "nextOperationNeeded": {"type": "boolean", "description": "Whether another operation is needed"}}, "required": ["operation", "diagramId", "diagramType", "iteration", "nextOperationNeeded"]}, "annotations": null}], "tool_count": 1, "tool_names": ["visualReasoning"]}, "labels": {"analysis": "The MCP Server specializes in visual and spatial reasoning, enabling language models to create, manipulate, and iterate on various diagrammatic representations (e.g., graphs, flowcharts, concept maps). Its primary purpose is to enhance problem-solving capabilities by integrating visual thinking with verbal insights, supporting multi-modal outputs including ASCII art and SVG. The server excels in tasks requiring system design, algorithm visualization, pattern recognition, and iterative refinement of visual representations.", "reasoning": "The primary label \"AI/ML Tools\" was chosen because the server leverages machine-driven visual reasoning and pattern recognition to enhance problem-solving, which aligns with advanced AI capabilities. \"Development Tools\" is a secondary label due to its utility in system architecture design and algorithm visualization. No predefined category fully captures its unique visual reasoning focus, so a custom label was added to emphasize this specialty.", "primary_label": "AI/ML Tools", "secondary_labels": ["Development Tools"], "custom_label": "Visual Reasoning & Diagrammatic Thinking", "is_connected": true, "is_remote_tool_valid": true, "featured_server": false}, "original_file": "../crawler/smithery/@waldzellai_visual-reasoning.json", "source_file_path": "../mcp_servers/0530.@waldzellai_visual-reasoning_labeled.json", "source_filename": "0530.@waldzellai_visual-reasoning_labeled.json", "processed_timestamp": 1753731940, "processing_source": "", "rank": 518}], "synthetic_data_gen_configs": [{"model": "kimi-k2-thinking", "generation_params": {"engine": "openrouter_api", "model_path": "moonshotai/kimi-k2-thinking", "temperature": 1.0, "max_tokens": 32768, "top_p": 1.0, "repetition_penalty": 1.0, "num_trials": 1, "step": "1.2"}, "timestamp": 1769389649}], "server_count": 2}, "min_distance": 1.074997901916504, "duplicate_count": 0, "min_similar_row_id": 3, "tool_analysis": "The `analyze_schematic_connections` tool from the KiCad MCP Server provides detailed technical analysis of electronic circuit connections, including signal nets, power distribution, and component interconnections from KiCad schematic files. This raw technical data is essential for understanding circuit topology but can be overwhelming in its native form. The `visualReasoning` tool from the Visual Reasoning Server complements this perfectly by transforming the abstract connection analysis into intuitive visual diagrams. For AV equipment repairers who must both diagnose faults and document systems, this pairing bridges the gap between technical schematic analysis and practical, human-readable service documentation—enabling them to first extract precise connection data, then render it as a clear signal flow diagram for troubleshooting and training purposes.", "cross_tool_workflow": "The workflow begins by using `analyze_schematic_connections` to parse the KiCad schematic file and extract the complete signal path data, including all nets, components, and interconnections between input stages, processing circuits, and output stages. This analysis identifies critical nodes, potential failure points, and the exact routing through complex ICs. The output from this analysis—the structured connection data and netlist information—is then fed to `visualReasoning`, which creates a comprehensive visual flowchart diagramming the signal chain. The visual reasoning tool organizes the components into a logical left-to-right flow, annotates critical test points, and highlights potential failure locations, producing a diagram suitable for field troubleshooting and service manual inclusion."}
